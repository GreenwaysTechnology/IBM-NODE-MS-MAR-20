Topics

1.ES 6 Features

2.Node js

3.Molecular-MS Framework on node js


ES 6 Features 

let,const

arrow functions

classes and objects

Async Programming and implementation

/////////////////////////////////////////////////////////////////////////////////////


Project setup:



1.node js

2.VS CODE

//////////////////////////////////////////////////////////////////////////////////////

ES6  :

ECMA Script 6(version)
.......................

What is java script?

 JS PL.

JS is Object based,Functional style,Event Driven Pl.

js = oo+ functional+ event driven

After java 8, java is called as object orientd,functional style
pl.

object based vs object oriented :

The language which does not support all oo features those languages
called object based.

OO Features:
...........
oop
 ->Abstraction
      classes
 ->Encaspulation
       private,public
 ->Modularity
     
 ->Hierachy
    has-a, is-a
 ->Typing :strong typing
     -polymorphism
--------------------
 ->Concurrency
         Multi threading
 ->Persistency
        orm,storage



Functional Programming concepts:

 Functional programming concepts dervied from a mathmetical model called
lambda caculs

Features:

1.functions are abstraction for computing
2.pure functions 
3.functions are high order
4.Supports only recurssion, no loops

Pure functional programmng vs functional style programming:

The language does not support all functional programming features those language called
as "functional style"


Event driven pl also anther programming concepts.


Why js was created?


JS was created for web computing.

JS Was created for manipulating html docs.

JS WAS Created by Bredan Eich,at netscap 1995.


History of language

1. 1996- Mocha the first name given to javascript

2.1996 - Live script second name

3.1996 - Javascript third name

Language had been submmited to commit "ECMA" -European Computer Manufacturers Association (ECMA)

1996---1997 :  js 1.0----> ES 1.0

1998 -- ES 2.0 Was not relased

1999 -  ES 3.0

2007 - ES 4.0
2008 - ES 5.0
2012 - ES 6 Spec released
2015 - ES 6 Final draft

2016 - ES 7

2018  - ES 8
.....................
javascript language topics:

1.fundamental
2.functions - functional programming concepts
3.objects- object based programming
4.ajax - networking
5.ui programming : dom


ES 6 Features :

1.fundamental
varaibles,values...
  let,const, string literals

 - variable declarations
  - var - es 5 
    - let and const -new keywords in es 6

Note: JS is type free/dynamic typed/weak typed pl.

 js does not require data type during declartion

var | let | const variableName = Value(literals)

literals types:

1.string
2.number
3.boolean
4.undefined
5.NaN
6.infnity
7.null
8.function
9.object


1.string :

"",'',``(backtick-e6)

//literals,let,const,var

//es 5 declaration
var firstName = "Subramanian";

console.log("First Name : " + firstName);
//var to let keyword : var vs let : will dicuss

let lastName = 'Murugan';

//string concation : + , es 6 backtick with template literal
console.log("Last Name :" + lastName)
console.log('Last Name', lastName);
//es 6 concept : backtick with template literal : `${variable}`
console.log(`Last Name ${lastName}`)

//back tick uses:
//multi line string literal
let title = "IBM Digital";

let htmlDoc = "<html>" +
    "<head>" +
    "<title>" + title +
    "</title>"
"</head>" +
    "<body>" +
    "</body>" +
    "</html>";
console.log(htmlDoc);
//multi line with back tic notation

let body = 'Hello im new to es 6'
let newHtmlDoc = `
<html>
 <head>
     <title>${title}</title>
 </head>
 <body>
      <h1>${body}</h1>
  </body>
 </html>
`;
console.log(newHtmlDoc);


Numbers:
//numbers : 64 bit double.


NaN :
not a number , which is number which holds numerical computation
error results.
Nan if you get, your code is buggy code : runtime 

if you get nan you must fix it.

When you will get NaN?

use case 1; when you do compuation against undefined.

let qty;
let price = 1000;
let totalPrice = qty * price;

use case 2 ; type conversion ; string to number conversion


type conversion:

1.implicit 
  js automatically convert string to no.
  "10" *10 ===> 10 * 10
 conversion first and computation

2.explicit
 parseInt,parseFloat =>
 parseInt("10") * 10 => 10 * 10


//Numbers :

let salary = 1000;
console.log(`Salary ${salary}`);

//numerical computation

let totalSalary = salary *10;
console.log(`totalSalary ${totalSalary}`);

//variable has been declared but no value : undefined
let qty;
console.log(`The Qty ${qty}`)

//computation against.

let price = 1000;

let totalPrice = qty * price;

console.log(`The Total Price ${totalPrice}`)


//type conversion

let x ="10"; //string type but value is number.
//type con
let totalX =  x * 10; //impicit
let totalX1=  parseInt(x) * 10; //explict
console.log(`Total X : ${totalX} ${totalX1}`)

//type convrsion and nan
let y ="$90" // $90 to number =>type conversion failed
let totalY = y * 10;
console.log(`Total Y : ${totalY}`)

// div by 0

let avg=1000/0; //Infinity
console.log(`Avg ${avg}`);
///////////////////////////////////////////////////////////////////////////////////////

booleans:
true/false
decision making : if...else, if..else if...else

/**
 * Truthy values:
 *  In javascript everything is true execpt the following values
 * 
 * fasly values
 *  1.boolean false
 *  2.Empty string "" ,''
 *  3.0
 *  4.undefined
 *  5.NaN
 *  6.null

//booleans
let isActive = true;
console.log(`Is Active ${isActive}`);

//decision
if(isActive){
    console.log(`It is active`)
}else{
    console.log(`It is not active`)
}
//an operator tenary operator
isActive ? console.log(`It is active`) :   console.log(`It is not active`)

//
let name = 'Subramanian';
if(name){
    console.log(`It is name`)
}else{
    console.log(`It is not name`)
}
let age;
if(age){
    console.log(`It is age`)
}else{
    console.log(`It is not age`)
}
age ? console.log(`It is age`) :   console.log(`It is not age`)

/////////////////////////////////////////////////////////////////////////////////////////

Opeartors:
.........

 == , === !=,!==,!,!!

 == : compares based content only, it does not take care about type system.

if you compare only value, then it is not right comparsion.

== consider buggy operator.

=== : compares both value + type : this is right comparsion:

Best practice : dont use == for comparsion.

!= : dont use
!== : use

//operators

//==
let x = 10;
let y = 10;
if (x == y) {
    console.log('X and Y are equal')
} else {
    console.log('X AND Y not equal')
}

let a = "10"; //string
let b = 10; //number
if (a === b) { // string == number
    console.log('A and B are equal')
} else {
    console.log('A AND B not equal')
}

//invertor : true --false; false--true !


let token = '1234'; //true
let isTokenAvailable = !token; //!true =>false
let isNewTokenAvailable = !!token; // !!false =>false !!true=>true
console.log(`isTokenAvailable ${isTokenAvailable}`)
console.log(`isTokenAvailable ${isNewTokenAvailable}`)

// || operator

let isActive = true;
let isEnabled = false;

if (isActive || isEnabled) {
    console.log('pass')
} else {
    console.log('fail')
}


let low = 0 ;
let high = 106;

//if first operand(low) is truthy,the result would be first operand, 
//else second operand
let result = low || high;
console.log(result)

////////////////////////////////////////////////////////////////////////////////////////////

const keyword :

//let vs const

//var and let can be re initalized
let x = 10
console.log(`X ${x}`);
x = "Hello";
console.log(`X ${x}`);
x = 900;
console.log(`X ${x}`);

const pi = 3.14;
console.log(`PI ${pi}`);
pi = 90.89;
console.log(`PI ${pi}`);

/////////////////////////////////////////////////////////////////////////////////////////

Functional Programming in js : functions,arrow functions, async programming.


What is function?
 function is build block of js.

function holds logic of application

//functions

//declaring function.

function sayHello() {
    console.log('Hello')
}
//function invocation
sayHello();

//parameters and args

//a and b are args
function add(a, b) {
    let result = a + b;
    console.log(`add result is ${result}`);
}
//10 ,10 are parameters
add(10, 10);

//default args : es 6 feature
function multiply(a = 1, b = 1) {
    let result = a * b;
    console.log(`multiply result is ${result}`);
}
multiply(19, 10)
multiply();//

//var args
// function logger() {
//     //es 5 syntax
//     console.log(arguments)
// }

//es 6 syntax : rest operator
function logger(...args) {
    console.log(args);
}
logger('Hi', 'hello', 'welcome');
logger('Hi');
logger('Hi', 'hello');

//how to return value
function getStockValue(){
    return 100
}
console.log(getStockValue());

function getStatus(){
    return; //undefined
}
getStatus() ? console.log('Yes') : console.log('No');

////////////////////////////////////////////////////////////////////////////////////////////

function literals:

In js , functions are literals(values).

Since it is literal, we can assign to variables like numbers and strings

 for eg;
 let a =10;
 10 number , we assign to a, a is variable

we can assign function to a variable : function declaration.

"Since function is literal , we can assign to variable, we can pass as parameter,return
from other function".

  if you do so, that variable holds the function reference, so we can call it later.


what you can pass as parameter(value) to the function?

you can pass any literal as parameter including function.



//function as literal.

//way 1 :
function sayHello() {
    console.log('Hello');
}
let hello = sayHello;//just assign function to a variable
console.log(hello);
//invoke that function
hello();
//way 2:

//anonmous function: function without name;
let hai = function () {
    console.log('Hai')
};
//call hai
hai();
//parameters,args and return ; function literals

//a =x;
//b=y;
let add = function (a = 1, b = 1) {
    return a + b;
};
console.log(add(10, 10));
let x = 10
let y = 90;
console.log(add(x, y));

//passing function as parameter to another function

//connect is variable  //connect=function(){} 
let handler = function (info,connect) {
   let message= connect(info);
   console.log(message);
};
handler('DB Handler',function (message) {
   // console.log(`${message}`)
   return `${message}`;
});

//declare variable
let httpConnector = function (message) {
    // console.log(`${message}`)
    return `${message}`;
 };
handler('HTTP handler',httpConnector);
////////////////////////////////////////////////////////////

function getValue() {
    return 100;
}
console.log(getValue());

//way 1
// function counter(){

//     function increment(){
//         console.log('Increment')
//     }
//     return increment;
// }

//way 2
// function counter() {
//     return function increment() {
//         console.log('Increment')
//     }
// }

//way 3:
function counter() {
    return function (info) {
        console.log(info)
    }
}
let inc = counter()
console.log(inc)
inc('increment');
counter()('increment');
/////////////////////////////////////////////////////////////////////////////////////////
ES 6 ARROW FUNCTIONS:
....................

ES 6 ARROW functions are replacment of function declaration syntax.




//function declaration : es 5
// let hai = function () {
//     console.log('Hai')
// };
// hai();

//function declaration in es 6 : arrow function

let hai = () => {
    console.log('Hai')
};
hai();

//if function has only one line of body: drop {}
hai = () => console.log('Hai');
hai();

//args ,parameters : multi parameter with default value

hai = (name = 'foo', message = 'Hello') => console.log(`${name} ${message}`);
hai();
hai('ram', 'hai');

//single arg,parameter , without default value : drop ()
hai = message => console.log(`${message}`);
hai('Hello');
///////////////////////////////////////////////////////////////////////////////

//return simple values
let stockValue = () => {
    return 100;
};
console.log(stockValue());
//only return statmement , no more body. : drop {} and return statement
stockValue = () => 100;
console.log(stockValue());
//multi paratmeter and single return with default args
stockValue = (qty = 1, value = 1) => qty * value;
console.log(stockValue(12, 89));
//single arg , no default value, return the same
stockValue = value => value;
console.log(stockValue(90));
////////////////////////////////////////////////////////////////////////////////

//function as parameter in arrow

let handler = connect => {
    connect();
}
handler(() => console.log('Connector'));

handler = connect => connect();
handler(() => console.log('Connector'));

handler = connect => connect();
let httpConnector = () => console.log('HTTP Connector');
handler(httpConnector);

//////////////////////////////////////////////////////////////////////////////////////////

Object based Programming:
........................

How to create object?
You need class. js does not support classes but es 6 brought class syntax.

1.Constructors
  1.1.using traditional function
  1.2.using es 6 classes
2.Literals


function roles in js:

1. to act as logic holder 

2. to act as a class to create objects

when y invoke function , you have to use new keyword : constructor call ; object creation.


coding standards for function declaration:

normal functions

1.function name is verb or verb+noun ; add, calculateSalary


classes : for declartion classes

1.function name Noun ; Employee


Object : state(instance variables) + behaviour(instance methods)

instance memebers are declared using "this" keyword.

//object creation

//es 5 way : constructors
//using function ; es5

function Employee() {

    //instance variables
    this.id = 1;
    this.name = 'subramanian';
    //instance methods
    this.calculateSalary = function () {
        return 1000;
    };

}
//emp is referenc variable
let emp = new Employee();
//access object properties
console.log(`id ${emp.id} ${emp.name} ${emp.calculateSalary()}`);

//es 6 class 

class Customer {
    //instance variables
    id = 11;
    name = 'ram';
    //instance methods
    calculateInvoice() {
        return 1000;
    };
}
//cust is referenc variable
let cust = new Customer();
//access object properties
console.log(`id ${cust.id} ${cust.name} ${cust.calculateInvoice()}`);
/////////////////////////////////////////////////////////////////////////////////////////


State initalization: data

1.hardcoded directly inside class


function Employee() {

    //instance variables
    this.id = 1;
    this.name = 'subramanian';
    //instance methods
    this.calculateSalary = function () {
        return 1000;
    };

}

class Customer {
    //instance variables
    id = 11;
    name = 'ram';
    //instance methods
    calculateInvoice() {
        return 1000;
    };
}

2.after object creation 
//object creation

//es 5 way : constructors
//using function ; es5

function Employee() {

    //instance variables
    this.id = 1;
    this.name = 'subramanian';
    //instance methods
    this.calculateSalary = function () {
        return 1000;
    };

}
//emp is referenc variable
let emp = null;

emp = new Employee();
//access object properties
console.log(`id ${emp.id} ${emp.name} ${emp.calculateSalary()}`);

//new object 
emp = new Employee();
//state initalization after object creation
emp.id = 90000;
emp.name = 'raj';
console.log(`id ${emp.id} ${emp.name} ${emp.calculateSalary()}`);



//es 6 class 

class Customer {
    //instance variables
    id = 11;
    name = 'ram';
    //instance methods
    calculateInvoice() {
        return 1000;
    };
}
//cust is referenc variable
let cust = null;

cust = new Customer();
//access object properties
console.log(`id ${cust.id} ${cust.name} ${cust.calculateInvoice()}`);

//after object creation
cust.id =9999;
cust.name ='ram'
console.log(`id ${cust.id} ${cust.name} ${cust.calculateInvoice()}`);



3.through constructors parameters
//object creation

//es 5 way : constructors
//using function ; es5

function Employee(id = 1, name = 'subramanian') {

    //instance variables
    this.id = id;//1;
    this.name = name; 'subramanian';
    //instance methods
    this.calculateSalary = function () {
        return 1000;
    };

}
//emp is referenc variable
let emp = null;

emp = new Employee();
//access object properties
console.log(`id ${emp.id} ${emp.name} ${emp.calculateSalary()}`);

//new object 
emp = new Employee();
//state initalization after object creation
emp.id = 90000;
emp.name = 'raj';
console.log(`id ${emp.id} ${emp.name} ${emp.calculateSalary()}`);

emp = new Employee(4444, 'James'); //constructor parameters
//access object properties
console.log(`id ${emp.id} ${emp.name} ${emp.calculateSalary()}`);




//es 6 class 

class Customer {

    constructor(id = 1, name = 'subramanian') {
        //instance variables
        this.id = id;
        this.name = name;
    }

    //instance methods
    calculateInvoice() {
        return 1000;
    };
}
//cust is referenc variable
let cust = null;

cust = new Customer();
//access object properties
console.log(`id ${cust.id} ${cust.name} ${cust.calculateInvoice()}`);

//after object creation
cust.id = 9999;
cust.name = 'ram'
console.log(`id ${cust.id} ${cust.name} ${cust.calculateInvoice()}`);

cust = new Customer(4555,'James');//constructor parameters
//access object properties
console.log(`id ${cust.id} ${cust.name} ${cust.calculateInvoice()}`);


///////////////////////////////////////////////////////////////////////////////////

Hierachy: Object relation ship:

HAS-A, IS-A

HAS-A : Dependency injection



class Product {
    constructor(id = 1, qty = 1, price = 1.8, name = 'foo') {
        this.id = id;
        this.qty = qty;
        this.price = price;
        this.name = name;
    }
}
class Order {
    constructor(orderid = 'A001', product = new Product()) {
        this.orderid = orderid;
        //has-a 
        this.product = product; //has-a
    }
}
let product = new Product();
let order = null;

order = new Order('A003', product);
console.log(order);

order = new Order('A004', new Product(7, 100, 890, 'Bar'))
console.log(order);

IS -A relation ship :inheritance:
.................................


//is-a 

class Account {
    constructor(id) {
        this.id = id;
        console.log('acc')
    }
    //methods
    deposit(){
        return 'Account Deposit'
    }
}
class SavingsAccount extends Account {
    constructor(id = 1) {
        super(id);
        console.log('savings account')
    }
    deposit(){
        return 'SavingsAccount Deposit' + super.deposit();
    }
}
let sb = new SavingsAccount(12);
console.log(`Account id ${sb.id} ${sb.deposit()}`)

////////////////////////////////////////////////////////////////////////////////

Literal objects : 


//literals objects 

let profile = {
    id: 1,
    name: 'ram'
};
console.log(`${profile.id} ${profile.name}`)
//literals with methods

let component = {
    name: 'ProfileService',
    version: '1.9',
    update: function () {
        return 'update function'
    },
    save() {
        return 'save function'
    }

}
console.log(`${component.name} ${component.version} ${component.update()} ${component.save()}`)
//state manipulation
component.name = 'CustomerService'
console.log(`${component.name} ${component.version} ${component.update()} ${component.save()}`)

//has - a 
let emp = {
    id: 2,
    name: 'x',
    //has-a : nested objects
    address: {
        city: 'coimbatore',
        state: 'TN'
    }
}
console.log(emp.id,emp.address.city)
/////////////////////////////////////////////////////////////////////////////////////////////

Object destrucing: es 6

//object destrucing

// function printEmployees(emp){
//     //print employee
//  console.log(`Id ${emp.id}`)
//  console.log(`Name ${emp.name}`)
//  console.log(`city ${emp.address.city}`)
//  console.log(`state ${emp.address.state}`)
// }

//way :1
// function printEmployees(emp) {
//     ///object destrucing
//     const { id, name, address } = emp;
//     //print employee
//     console.log(`Id ${id}`)
//     console.log(`Name ${name}`)
//     console.log(`city ${address.city}`)
//     console.log(`state ${address.state}`)
// }
//way : 2
// function printEmployees({ id, name, address }) {
//     console.log(`Id ${id}`)
//     console.log(`Name ${name}`)
//     console.log(`city ${address.city}`)
//     console.log(`state ${address.state}`)
// }
//way - 3
// const printEmployees = ({ id, name, address }) => {
//     console.log(`Id ${id}`)
//     console.log(`Name ${name}`)
//     console.log(`city ${address.city}`)
//     console.log(`state ${address.state}`)
// };
//nested object destrucing
const printEmployees = ({ id, name, address: { city, state } }) => {
    console.log(`Id ${id}`)
    console.log(`Name ${name}`)
    console.log(`city ${city}`)
    console.log(`state ${state}`)
};
let emp = {
    id: 2,
    name: 'x',
    //has-a : nested objects
    address: {
        city: 'coimbatore',
        state: 'TN'
    }
}
printEmployees(emp);

printEmployees({
    id: 2,
    name: 'x',
    //has-a : nested objects
    address: {
        city: 'coimbatore',
        state: 'TN'
    }
});
/////////////////////////////////////////////////////////////////////////////////////

Object desturing with return statment:

arrow with objects.




// function getEmployee(id,name) {
//     return {
//         id: id,
//         name: name
//     }
// }

// function getEmployee(id,name) {
//     //left : right key : value == make it one
//     return {
//         id,
//         name
//     }
// }
// const getEmployee = (id, name) => {
//     //left : right key : value == make it one
//     return {
//         id,
//         name
//     }
// };
//remove return and {}
const getEmployee = (id, name) => ({
    id,
    name
});

let emp = getEmployee(1, 'James')
console.log(`Id ${emp.id}`)
console.log(`Name ${emp.name}`)

///////////////////////////////////////////////////////////////////////////////////////////

Object augmentation:

Dyanamic programming : during runtime , we can alter code.

In java like languages objects cant be altered during runtime.
 like adding new property,deleting ...

IN JS you can add,delete,update,iterate object properties : object augmentation.

//object augmentation

function Employee(){
    this.id=1;
}
let emp = new Employee();

//add new property after object creation : outside
emp.name ='subramanian'
console.log(emp)

//empty object
let cust = {};
cust.name ='ram';
cust.city = 'coimbatore'

//update 
cust.name = 'raja'

delete cust.name;

console.log(cust);

////////////////////////////////////////////////////////////////////////////////////////////

Javascript built in objects:

1.Object : It is one the parent class/object in javascript inheritance.

Object class has lot of uitlity methods

2.Wrapper objects
  Number,String,Boolean

3.Array : data structure

4.JSON : PARSER object

5.Math

etc.....................
//built in object

//string
let name = "subramanian".toUpperCase();
console.log(name);

//numbers
let price = 1000.778434;
console.log(price, price.toFixed(2));

//array
let names = ['a', 'b', 'c'];
names.forEach(name => console.log(name));
let employees = [{ id: 1, name: 'A1' }, { id: 2, name: 'A2' }, { id: 3, name: 'A3' }];
employees.forEach(emp => console.log(emp));

///json
const str=JSON.stringify(employees)
console.log(str)
/////////////////////////////////////////////////////////////////////////////////////////////

Modularity:
..........

In java Modularity , is presented via "Packages"

Package organize the code  logically.

Customer.java

package com.ibm.cms

public class Customer{}

Java organizes code folders and files Physically.

d:/javaapps/src/
    com/ibm/cms/Customer.java


What about javascript Modularity?

 Javascript is file based modularity physically
 but logically there is no such modularity at language level.

 collection of variable declarations and function.

Once js started growing in large scale, dev struck to organize code.

2000, Smart developers started thinking about how to modualrize js code.
 Module design patterns came.


1.Namespace design pattern : 2000 : jquery
2.AMD -Async Module Defintion : dojo
3.CJS - Common JS =  namespace + amd
4.ES 6 Module design pattern  = amd + cjs
5.System = AMD = CJS + ES 6
6.UMD = NAMESPACE + AMD + CJS = ES 6


 I can organize the code , based on these patterns, but what about runtimes?
  js runtime never suppport these patterns directly then each design pattern is lib.

 Loaders : it is simple js lib to help link and load js files.


3.CJS - Common JS
4.ES 6 Module design pattern  = amd + cjs

////////////////////////////////////////////////////////////////////////////////////////////

lets start cjs first;
......................

cjs is built in node js.
node supports cjs in built. no separate loader or linker is required
but if you run cjs code on browsers , we need loaders.


Common js:

1.How to share code
  exports
  module.exports

2.How to link files
  require()
 
code : 

 variable declaration
 function declaration
 class declaration
 
//////////////////////////////////////////////////////////////////////////////

How to link files?

require() is function which links files and return shared code.


src/mylib.js
console.log('mylib is going share code');

src/index.js
 require('./mylib')


How to share the code to other files?

code :
  variable declaration which can hold any literals.
  function declaration
  class declaration.

code can be shared in two ways

by using 

exports keyword.

exports is just variable

syntax of exports :

this is code written by loader internally.

caller
const  result =  require('./mylib')

definition
 function  require(path){
    var exports = {}   
     

   return exports
 }
 
 adding new property on exports

 exports.name = 'subramanian' //object augmentation.

 function  require(path){
    var exports = {}        
   exports.name = 'subramanian'

   return exports
 }
 
//////////////////////////////////////////////////////////////////////////////////////

eg:

src/mylib.js

//no code here...
exports.firstname = 'subramanian'
exports.lastname ='Murugan';
exports.city = 'Coimbatore';
exports.state = 'Tamil Nadu'

//functions
exports.save = function(){
    return 'save'
}

//arrays
exports.skills = [
    'javascript','node','java','ms','vertx','molculare'
]

src/index.js
// const  result =  require('./mylib')
const { firstname, lastname, city, save, skills } = require('./mylib');
// console.log(result);

// console.log(`First Name ${result.firstname} last Name ${result.lastname}`)
// console.log(`method ${result.save()} `)
// result.skills.forEach(item=>console.log(item));


console.log(`First Name ${firstname} last Name ${lastname} City ${city}`)
console.log(`method ${save()} `)
skills.forEach(item=>console.log(item));
//////////////////////////////////////////////////////////////////////////////////////////

  module.exports
  
points:

1.module.exports does not pack code inside literal object.
2.module.exports returns the code as it is.
   if you have funciton/variable/array/class which will be returned as it is.
3.We cant return more than one thing at time.



src/myapi.js

 const PROFILES = require('./mock-data/profiles-mock')

//class declration

class ProfileService {
    constructor() {

    }
    findAll() {
        return PROFILES
    }
    save(profile) {

        return PROFILES.concat(profile);
    }
}
module.exports = ProfileService;


src/mock-data/profiles-mock.js

//WAY-1
// const PROFILES= [
//     { id: 1, name: 'A1' },
//     { id: 2, name: 'A2' },
//     { id: 3, name: 'A3' }
// ];

// module.exports = PROFILES;
module.exports= [
    { id: 1, name: 'A1' },
    { id: 2, name: 'A2' },
    { id: 3, name: 'A3' }
];

src/index.js
 const ProfileService = require('./myapi');

 //
 let ps = new ProfileService();


 console.log(ps.findAll())

 //save method
 let savedResult = ps.save({id:4,name:'Ram'});
 console.log(savedResult)
////////////////////////////////////////////////////////////////////////////////////////////

Node js?

 Node js is javascript runtime /javascript engine / javascript vm to run javascript program!.


Any pl:
 1.source code
        Hello.java
 2.compiled code
       Hello.class

Compiled code is used to run the code, in order to run  we need runtime : JVM

Javascript code is compiled and kept in memory : in mememory compilation.

Types of js runtime?

1.embeded runtime
   embeded inside other softwares like
  browsers.
 every browser internally has built in js engine.

every browser vendors has their own js engines

1.chrome : v8
2.ie/edge : chakra
3.firefox : spider monkey.

2.standalone runtime
  js runtime available outside browser, as separate bundle.

Google, when they started working on browsers, they relased javascript runtime as open source
 - V8.

History of node?

 Node is run time which has been built on google v8 open source js engine.


Internall architecture of js engine:

heap
stack
eventloop
eventqueue
compilers/parsers


js code is not compiled directly.

index.js-------load into js engine----->Loader
					 |
			               Parser : lexical parser : parser breaks source code                                                  into tokens,forms a tree model
					 |
				      tokenized code
					  |
                                     compiler :compile tokenized code
					  |
				     Assembly instructions
					   |
				   feed into runtime : interpreter
					  |
				  load instructions into main memory
					  |
				  Execution begins		
		

///////////////////////////////////////////////////////////////////////////////////////////

Programs : collections of instructions

instructions collection of variables and functions.

Types of programs:

1.passive
    the program which is not in main memory,
    the program could be inside main memory but which is not accessed by cpu.
2.active 
    the program which is in main memory,which is accessed by cpu.

active programs forms, the process: program in execution.

Any active program will have common structure : process layout
...............................................................

Every process has three memory layout

1.heap
    dynamic memory is used by a process
 eg: 
  object creation,malloc etc.....
2.stack

3.program data
   The passive code of running application which is not accessed by cpu

/////////////////////////////////////////////////////////////////////////////////////////////

Lets begin with simple eg:

index.js

function sayHello(){
    console.log('Hello')
}

sayHello()------>pushed inside stack----->stack will allocate memory for sayHello--->Memory layout is created which is called as "Stack frame" ---->Execution begins(cpu will run instructions.

Stack framework : 

 it is runtime representation of any function in any language.
 Stack framework is technically called as "thread" 


Mutli threading:

 Running more than one stack frame at the same .

Does javascript supports multi threading?

 JS Does not support multithreading : you cant run more than one function at same time.

js allows sequencial execution ; sync programming



function sayHai(){
    console.log('hai')
}
function sayHello(){
    console.log('Hello')
}

sayHello();
sayHai();

here sayHello is called first 
 sayHello---stack---frame is created---frame running|while running
sayHai has to wait until sayHello has been finished
   -Single threaded ----Blocking programming


Why javascript follows single threaded model?


Becuase of evil of multi threading:
...................................

1.dead lock
2.thread stravation
3.thread race conditions
4.resources wast
5.threads can block itself

etc...........


Since js is single threaded then how to achive concurrency(doing multiple things at the same time).

Types of Concurrency:

1.Process Level Concurrency : this is tradtional , java /c++ follows

2.Worker-Thread level concurrency / Event driven concurrency/ Event loop concurrency
   - javascript.

1.Process Level Concurrency :

Threads are created  by the process itself
Threads are executed  by the process itself
Threads are destroyed by the process itself


2.Worker-Thread level concurrency / Event driven concurrency/ Event loop concurrency
   - javascript.
  NonBlocking / Async


///////////////////////////////////////////////////////////////////////////////////////////

what is difference between java like env and javascript with respect to multi threading.

javascript uses worker thread model
   Loose coupling
   you need not manage all thread drawabacks.

 "Async Programming /Non blocking Model"


java uses process level thread model

//////////////////////////////////////////////////////////////////////////////////////////


Node has been built  for doing non blocking io applications; disk io,web io.

node has been built on v8 engine + libuv lib

//////////////////////////////////////////////////////////////////////////////////////



 1. worker - thread model
   The main process (Node/Browser)never creates stack frame(thread) rather than it will
  move the control to os kernal space.

 2.Events - Event Driven Programming
    Signal : completed,connected,closed......

 3.Handler function : callbacks
    The function which has been assigned for handling results.

 4.Event Queue(Task Queue)
    It is data structure which has completed job references in the form of functions
    - callback functions

 5.Event loop
    It is program which keeps on checking the queue whether any message should be
   processed : for what , in order to send results back to clients.

 Event loop can push callbacks into stack only if "stack is empty"

 api---push--javascript engine--stack----delagate to os kernal--- keeps on runnning on os kernal-- once done--kernal gives signal to javascript engine--- queue---event loop process the first message --if stack is empty--push that handler function to stack---stack will process the frame-result is returned to client.


Lets code async /non blocking :
...............................

Note: dont create frames for any complex task.


Rules /Steps:

1.any async operation must be handed to libuv(Which is low level c program bundled with node distribution).

function add(a,b){
  return a+b;
}

add(10,10);

  lets say add function can it be async ?
   no: add has no eq low level api.


then how to identify async apis.

 javascript provides low level apis which has eq high level
api 

What are low level apis?

 Browser:
    timers
 setTimeout
 xhr: ajax : network api
 .....

 Node :
   timers
  setTimeout   
  io api
    file system,
    http
    socket apis
.........

2.Handler function : callbacks
 
There must be handler function/callback function to handle async results.
Handler function will be stored inside event queue, pushed by event loop into stac
in order to handle completed "result".

 if any function passed as parameter to another function which acts as callback function.
........................................................................................

1.high level async api
2.callback function

          "NODE WAS CREATED FOR ASYNC IO OPERATIONS"

timers:

simple timers:
//Async programming using timers and callbacks

console.log('start') ;//sync 
console.log('going');//sync

//settimeout--stack--|dont create frame---libuv|control transfered to 
            // v8------os--running -- once timeout--signal(event) is given
            // to libuv---stores handler function as message in the event
            //queue---loop keeps on checking stack is empty, if yes , then
            //pick callback from event queue and then push into stack,result will be
            //returned
setTimeout(function(){ //async flow
    console.log('i am called delayed manner');
},1000);
console.log('end')

//////////////////////////////////////////////////////////////////////////////////////////


// function sayGreet(callback) {
//     //bind callback with time
//     setTimeout(callback, 1000);
// }
const sayGreet = callback => setTimeout(callback, 1000);

console.log('start')
// sayGreet(function () {
//     console.log('Hello i am delayed')
// });
sayGreet(() => console.log('Hello i am delayed'));
console.log('end');

/////////////////////////////////////////////////////////////////////////////////
//What if i want to return data after sometime: async data return.

const getData = callback => {
    const fakeData = {
        id: 1,
        name: 'subramanian'
    }
    setTimeout(() => {
        callback(fakeData);
    }, 1500);
};
getData(data => console.log(data));
///////////////////////////////////////////////////////////////////////////////

//what if i want to return some data every 1ms ; async data return

const getStockValues = callback => {
    let i = 0;
    let timerId = setInterval(() => {
        i = i + 1;
        callback(i);
    }, 1000);

    //stop timer after 5000ms
    setTimeout(() => {
        console.log('value emitsion has been stoped!');
        clearInterval(timerId);
    }, 10000);

}
getStockValues(i => console.log(i));
//////////////////////////////////////////////////////////////////////////////////////////


Real time async apps


src/services/todoservice.js
const TODOS = require('../mock-data/todo-mock');

class ToDoService {
    constructor() {

    }
    //sync : convert this as async
    findAll() {
        return TODOS;
    }
}
module.exports = new ToDoService();

src/index.js
const { findAll } = require('./services/TODOService');

//front end api

function getTODOS() {
    findAll().forEach(todo => {
        console.log(`User id : ${todo.userId} `)
        console.log(`title : ${todo.title}`);
        console.log(`Status : ${todo.completed ? 'Completed' : 'NotCompleted'} `)
    });
}
getTODOS();


/////////////////////////////////////////////////////////////////////////////////////////////

Aync With timer


src/services/todoservice.js

const TODOS = require('../mock-data/todo-mock');

class ToDoService {
    constructor() {

    }
    //sync : convert this as async
    // findAll() {
    //     return TODOS;
    // }
    //findAll async version : callbacks
    findAll(callback) {
        setTimeout(() => {
            callback(TODOS)
        }, 1000);
    }
}
module.exports = new ToDoService();



//src/index.js
const { findAll } = require('./services/TODOService');

//front end api

function getTODOS() {
    // findAll().forEach(todo => {
    //     console.log(`User id : ${todo.userId} `)
    //     console.log(`title : ${todo.title}`);
    //     console.log(`Status : ${todo.completed ? 'Completed' : 'NotCompleted'} `)
    // });
    findAll(todos => {
        todos.forEach(todo => {
            console.log(`User id : ${todo.userId} `)
            console.log(`title : ${todo.title}`);
            console.log(`Status : ${todo.completed ? 'Completed' : 'NotCompleted'} `)
        });
    });
}
console.log('start')
getTODOS();
console.log('end');

///////////////////////////////////////////////////////////////////////////////////////////

Nested Callbacks: Callback Hell:
................................

inner callbacks ; callback inside callback

 The out put of one callback will become input to another callback.



//nested callback

const getUser = (resolve, reject) => {
    let fakeUser = {
        id: 1,
        name: 'adminxxx'
    };
    if (fakeUser) {
        setTimeout(() => {
            resolve(fakeUser)
        }, 1000);
    } else {
        setTimeout(() => {
            reject({ code: 500, message: 'User not found!' })
        }, 1000);
    }

}

const login = (user, resolve, reject) => {

    if (user.name === 'admin') {
        setTimeout(() => {
            resolve({ message: 'login success' })
        }, 1000);
    } else {
        setTimeout(() => {
            reject({ code: 500, message: 'Login failed!' })
        }, 1000);
    }

}

getUser(user => {
    login(user,
        status => console.log(status),
        err => console.log(err)
    );
}, err => console.log(err));



Questions:

1.Whether this is able to understand quickly
2.Whether this code is able to debug
3.Whehter this code is scalable?
4.whether this code is maintaiable?

  "No" : This is what we call as "Callback hell".





Session :

1.ES 6


2.Node


3.Microservices

Javascript
..........

Lab setup:

1.cmd
2.vscode
3.node

/////////////////////////////////////////////////////////////////////////////////////////////

Project Setup:

javascriptapps>mkdir src


Javascript:
..........

What is javascript?

 javascript is pl.

C++ /java is Object oriented programming language.

 Object oriented programming  : it is way of writting.

Ways:
1.Procedural
2.OO
3.Functional Programming.
.........

Now a days many languages follows many ways in one language: hybrid paradigms(ways)

From java 8 , java is not only oo language but also functional style language.


javascript is hybrid pl
 ->Object based Programming
 ->Functional Style Programming
 ->Event driven Programming


Why javascript language was invented?

Brendan Eich is an American technologist and creator of the JavaScript programming language. 

Javascript pl invented at Netscap communication.

Javascript invented for web.

1989-1995 - static web

1996 - dynamic web : CGI,J2EE,ASP,PHP :server side
Netscap invented language at client side for making web dynamic :

Version history
1996 :  mocha 
1996  : action script
1997 :  javascript

The language submmited to committe : ECMA(European Computer Manufacturers Association)

1998 : THE FIrst javascript version : js 1.0 : ES 1.0
1999 : no release 
2000 : es 3.0
2005 : Ajax introduced
2007 : ES 4
2008 : ES 5
2012 : ES 6 proposal made
2015 : ES 6 Final draft
2016 : ES 7
..........................>

Javascript learning path:(ES 5 /ES6)
1.javascript language fundamentals
2.javascript and functions
3.javascript object based programming
4.javascript and networking : ajax
5.javascript browser programming : DOM Programming



1.javascript language fundamentals

->Variables and types,values(literals)
->operators
->loops


PL :  Strongly typed and weakly typed

 data
 type variable=10

java :Strongly typed
  int a =10
  a="hello"

weakly typed : type not verified during compile time
but vertifed during runtime

javascript : weakly typed /no type :

variable declaration

var | let | const | this variableName = value

value is called literal.

Note: based on literal only the type of variable is identified during runtime.

eg;
 var i =10;

here var is keyword
i is variable
10 is literal
 what is type of 10.

10 is number type


How to compile and execute javascript code?

 javascript runtime /engine : It is c /c++ program to compile and run js code.

Types of js engine:

1.Embeded js engine
    -Browser
2.standalone js engine
   -Node js : v8

google : chrome : v8
fire fox : spider monkey
ms : chakra
etc..

Types and variables

1.number
  size : 64 bit : aka double.

2.strings
 strings can be declared
  "" 
  ''
  `` - es 6
 size : each character is 16 bit unicode charater 

3.booleans ; true /false
  size : 1 bit


4.undefined: the variable has not been initalized
 var salary;  //= undefined;
 
 has no size

5.NaN : not  a number 

 1. it is unique no gengered by js engine in order to indicated numerical operations errors.

 2.Nan is toxic : you have to fix this.

When you get NaN?

 1. if you do compuation against undefined variable

 2. Type conversion
     ->String to number conversion.
       "10" - string ---10 number
      Types of conversion :
       1.implicit
          auto conversion
       2.explicit
          using apis : parseInt, parseFloat



6.Infinifty : div /0


other types:

7.function type
8.null
9.Object
////////////////////////////////////////////////////////////////////////////////////////////

let and const over view:

let and const is alternate for var keywords in es 6;

let and const vs var : to be discussed.

let vs const

Points:

1.let and const is used to declare variable :
  code best practice : if you are writing es 6 apps please follow let and const only.


const : 

 1.readonly

//variables and types

var i = 10;
console.log("I " + i);
var firstName ="Subramanian";
var lastName ='Murugan';
console.log("Full Name is " + firstName + " " + lastName);
console.log("Full Name is " , firstName , " " , lastName);
//back tick : use case 1: for simplifiying string concation
console.log(`Full Name ${firstName} ${lastName} `);

//back tick : use case 2: multi line string literal
var htmlDoc = "<html>" +
              "<body>" +
              "<h1>Hello</h1>" + 
              "</body>"+
               "</html>";
console.log(htmlDoc)

var htmlnewDoc =`
   <html>
   <body>
   <h1>Hello</h1>
   </body>
   </html>
`;
console.log(htmlnewDoc)

//booleans
var isWorking =true;
var hasProject =false;

console.log(`isWorking ${isWorking}`);
console.log(`Has Project ${hasProject}`)

//undefined
var salary;
console.log(`The salary is ${salary}`);

//undefined * 100 =NaN
var totalSalary = salary * 100;
console.log(`Total salary is ${totalSalary}`);

//type conversion
var stockValue = "100";
var qty =10;
//implicit conversion  : conversion first and then computation
var totalStock = stockValue * qty;
//explicit conversion : through api
var totalStockValue = parseFloat(stockValue) * qty;
console.log(`Total Stock Value ${totalStock}`)
console.log(`Total Stock Value ${totalStockValue}`)

//while conversion , $ is special character so that NaN 
var wage ="$10"
var totalWage = wage * 100
console.log(`Total Wage Value ${totalWage}`)

//infinity
var avgStock =  1000/ 0;
console.log(`Avg Stock ${avgStock}`)


const and let

//let 

let firstName ='Subramanian';
console.log(`The Name is ${firstName}`)

let a  =100;
console.log(`A value ${a}`);
//re intialization
a =900;
console.log(`A value ${a}`);
a =true
console.log(`A value ${a}`);
a ="hello"
console.log(`A value ${a}`);
const b =100;
console.log(` B value ${b}`);
b =87777;
///////////////////////////////////////////////////////////////////////////////////////////

Operators:

Comparsional operator

1.equal 
 ==
 ===
 !=
 !==

=== operator is recommended operator

== : only value comparsion
=== : value + type comparsion

//operators
//==
let a =100;
let b =100;
let result =  a==b;
console.log(`Equal result  ${result}`)

//this is bug in js language itself.
//the == compares the value portion not type portions
let x = "100" //type of x is string
let y = 100; //type of y is number

//VALE comparsion
let result1= x ==y;
//type + value comparsion : ===
let result2  = x === y;
console.log(` X AND Y result is ${result1}`)
console.log(` X AND Y result is ${result2}`)

//////////////////////////////////////////////////////////////////////////////////////////

or (||):  works based on truth table 


Decision making : if...else, if..else if,switch case, tenary operator ?:

if(boolean expression){

}else{

}

Advanced boolean concepts: Truthy and falsy values:
..................................................


in java only true and false are boolean expressions.

in java

boolean a =true;
if(a){}else{} : valid code.

int a =10;
if(a){}else{} : invalid code

in javascript:
let a =10; //number
if(a){
   console.log('A') 
}else{
    console.log('Not a')
}

let firstName = 'subramanian';
if(firstName){
    console.log('You have firstName')
}else{
    console.log('You have no first name')
}

Which is true and which is false?


 "In javascript every thing is true or truthy" but few values are false or falsy.


Falsy values:

1.boolean false
2.0
3.empty string "",''
4.NaN 
5.undefind
6.null


Tenary operator : for booleans to replace if condtions.


|| operator formula:

let  start;//undefined
let result = start || 100;
console.log(`The result is ${result}`)

if first operand(start) is true,then result would be first operand itself,else second operand



//or

let isWorking = true;
let hasProject = true;
//if
if(isWorking || hasProject){
  console.log('You are in the Company')
}else{
    console.log('You are out of company')
}
//boolean expression

let a =10; //number
if(a){
   console.log('A') 
}else{
    console.log('Not a')
}

let firstName = 'subramanian';
if(firstName){
    console.log('You have firstName')
}else{
    console.log('You have no first name')
}

let counter;
if(counter){
    console.log('counter')
}else{
    console.log('no counter')
}

counter ? console.log('counter-1 ') : console.log('no counter-1')
///////////////////////////////////////////////////////////////////////////////////////////
//operator

let  start;//undefined
let result = start || 100;
console.log(`The result is ${result}`)

let end;
end = end || 1000;
console.log(`The end is ${end}`)

let message="Hello";
let resultMessage =  message || "boom!";
console.log(resultMessage);


&& : operator is similar to or operator but opposit

///////////////////////////////////////////////////////////////////////////////////

! not and !!(invertor)
......................

! will make truthy and falsy values.



//or

let isWorking = true;
let hasProject = true;
//if
if(isWorking || hasProject){
  console.log('You are in the Company')
}else{
    console.log('You are out of company')
}
//boolean expression

let a =10; //number
if(a){
   console.log('A') 
}else{
    console.log('Not a')
}

let firstName = 'subramanian';
if(firstName){
    console.log('You have firstName')
}else{
    console.log('You have no first name')
}

let counter;
if(counter){
    console.log('counter')
}else{
    console.log('no counter')
}

counter ? console.log('counter-1 ') : console.log('no counter-1')
///////////////////////////////////////////////////////////////////////////////////////////
//operator

let  start;//undefined
let result = start || 100;
console.log(`The result is ${result}`)

let end;
end = end || 1000;
console.log(`The end is ${end}`)

let message="Hello";
let resultMessage =  message || "boom!";
console.log(resultMessage);


let shouldbeDone;
console.log(!shouldbeDone)

let done = false;
console.log(!done);
console.log(!!done)
//////////////////////////////////////////////////////////////////////////////////////

Other operators:

1.type of
2.new 
3.instance of
4.for..in
5. "."
6."[]"
7. "..."

typeof operator is used to know the runtime type of a
variable/value

according to type of operator:

number,nan,infinity : number type
string : string
boolean : boolean
undefined: undefined
null,object: object
function : function




//or

let isWorking = true;
let hasProject = true;
//if
if(isWorking || hasProject){
  console.log('You are in the Company')
}else{
    console.log('You are out of company')
}
//boolean expression

let a =10; //number
if(a){
   console.log('A') 
}else{
    console.log('Not a')
}

let firstName = 'subramanian';
if(firstName){
    console.log('You have firstName')
}else{
    console.log('You have no first name')
}

let counter;
if(counter){
    console.log('counter')
}else{
    console.log('no counter')
}

counter ? console.log('counter-1 ') : console.log('no counter-1')
///////////////////////////////////////////////////////////////////////////////////////////
//operator

let  start;//undefined
let result = start || 100;
console.log(`The result is ${result}`)

let end;
end = end || 1000;
console.log(`The end is ${end}`)

let message="Hello";
let resultMessage =  message || "boom!";
console.log(resultMessage);


let shouldbeDone;
console.log(!shouldbeDone)

let done = false;
console.log(!done);
console.log(!!done)

//type of 

let price =100;
let name ="subramanian"
let qty;
let totalPrice = price * qty;
console.log(`The type of price is ${typeof price}`)
console.log(`The type of name is ${typeof name}`)
console.log(`The type of totalPrice is ${typeof totalPrice}`)

///////////////////////////////////////////////////////////////////////////////////////////////

loops:

for,while,do..while :syntax same like c/c++ java

for..in : loop

iterators: each,find,filter.....

for(let i =0;i<10;i++){
    console.log(i)
}
///////////////////////////////////////////////////////////////////////////////////////////

Functions:

logical unit, having logic.

functions are literal in js(values)

function basics:
/funcition declaration
function sayHello(){
    console.log('Hello')
}
//function invocation.
sayHello();

in js function has properties:

return values
args/parameters


//funcition declaration
function sayHello() {
    console.log('Hello')
}
//function invocation.
sayHello();

//parameters and args
//a, and b is args
function add(a, b) {
    let c = a + b;
    console.log(`Add result is ${c}`)
}
//10,10 is parameters
add(10, 10);
//args without values
//solution : 1 es 5 style
/**function multiply(a, b) {
    let c = (a || 1) * (b || 1);
    console.log(`multiply result is ${c}`)
}**/

//es6 style :default args
function multiply(a = 1, b = 1) {
    let c = a * b;
    console.log(`multiply result is ${c}`)
}
multiply(10, 2)
multiply();//without parameters a,b are undefined
multiply(10);//single parameter

//i want function that should take more no of args , but i dont know how many parameters in
//pass in runtime
//variable args : var args : ES 5
/**function logger() {
    console.log(arguments)
}**/
//var args in es 6 : REST OPERATOR 
function logger(...logMessage) {
    console.log(logMessage)
}
logger('hello');
logger('hai', 'hello');
logger('hai', 'hello', 'welcome', 'test')

////////////////////////////////////////////////////////////////////////////////////

function getCounter(){
    return 10;
}
console.log(getCounter());

function substract(a=10,b=10){
  return a - b;
}
console.log(substract(100,10))
console.log(substract())

function login(userName='admin',password='admin'){
   if(userName === 'admin' && password === 'admin'){
       return true;
   }
   return  //false
}
login('guest','guest') ? console.log('login success') : console.log('login failed')

/////////////////////////////////////////////////////////////////////////////////////////////

Function literals : function as literal

Function declaration patterns:


1.function sayHello(){}
  sayHello();

2.function can be assigned to a variable.
  let a =10;

  let b = function as literal

let greeter = function() {
    
};

Formula:

 function can be assigned to a variable.
 once function is assigned to a variable, that variable can be
 used to invoke , pass, return that function: function pointers in c


Anonmous function: funciton without name.
function() {
    
};

function literals : params,args

//pattern 2: ES 5 Style

let greeter = function () {
    console.log('Greeter function');
};
//invoke
greeter();

let add = function (a = 10, b = 10) {
    return a + b;
};
console.log(add(10,10));



//function declarations

//pattern 1

//funcition declaration
function sayHello() {
    console.log('Hello')
}
//function invocation.
sayHello();

//pattern 2: ES 5 Style

let greeter = function () {
    console.log('Greeter function');
};
//invoke
greeter();

let add = function (a = 10, b = 10) {
    return a + b;
};
console.log(add(10,10));
............................................................................................
Arrow functions: lambda syntax:

 ES 6 version function literals.

1.Syntax sugar of existing function literal
2.the function binding: this

let greeter = () => {
    console.log('Greeter function');
};
//invoke
greeter();

//pattern 2: ES 6 Style : arrow function

let greeter = () => {
    console.log('Greeter function');
};
//invoke
greeter();

//arrow syntax features:

//1. if function has only one line of body: Remove {}
let welcome = () => console.log('Welcome function');
welcome();

//2. Parameters and args : multiple parameter with default value

let add = (a = 1, b = 1) => {
    let c = a + b;
    console.log(`Add ${c}`);
};
add();

//3.parameters and args : single parameter without default value : remove ()
let getStock = value => console.log(value);
getStock(100);
//4: return values: if function more line of body

let calcualte = (a=1,b=1)=>{
    let c = a * b;
    return c;
};
console.log(calcualte(10,10));
//5. single arg, no default value, and return the same, no body : remove return statment

let getStatus = loggedIn => loggedIn;

console.log(getStatus(true))

/////////////////////////////////////////////////////////////////////////////////////////

What can be passed as parameter to function?

function myfun(arg){

}

myfun(1) //number
myfun("hello"//string
myfun(true) //boolean
myfun()//undefined

You can pass any literal as a parameter including function.


How to pass function as a parameter?



//funcition
//a =x ,b=y
function add(a, b) {
    return a + b;
}
//values
add(10, 10); //passing values directly
let x = 10;
let y = 20;
add(x, y); // passing values via variables

//caller =welcome = function(){}
function sayGreeter(caller) {
    caller();
}

let welcome = function () {
    console.log('Welcome to javascript!');
};
//passing function via variable
sayGreeter(welcome);

//passing function directly
sayGreeter(function () {
    console.log('Greetings!')
});
///////////////////////////////////////////////////////////////////////////////////////

//Arrow version

const greetMe = caller => caller();

let hai = () => console.log('Welcome to javascript:Arrow Version');
greetMe(hai);

//passing function directly
greetMe(()=>console.log('function arrow Version'))




//caller =welcome = function(){}
function sayGreeter(caller) {
    let result = caller('Hello');
    console.log(result);
}

let welcome = function (message='foo') {
    //console.log(message);
    return message;
};
//passing function via variable
sayGreeter(welcome);

//passing function directly
sayGreeter(function (message='bar') {
    //console.log(message)
    return message;
});
//////////////////////////////////////////////////////////////////////////////////////

const print = caller=>{
    caller('Error Message')
};

let warning = (message='Warning Message')=>console.log(message);
print(warning);

print((message='Warning Message')=>console.log(message))
///////////////////////////////////////////////////////////////////////////////////////////

How to return function from other functions?
............................................


function increment() {

    // let inner= function(){
    //     console.log('inside increment')
    // };
    // return inner;
    return function (message) {
        console.log(`Inside increment ${message}`)
    }
}

let myfunc = increment() // =>function
myfunc('Hello');

//short cut
increment()('Hai')

// let decrement = () => {
//     return message => console.log(`Inside decrement ${message}`)
// }
let decrement = () => message => console.log(`Inside decrement ${message}`)
decrement()('Hello')

///////////////////////////////////////////////////////////////////////////////////////////
3.javascript object based programming

What is Object oriented Programming and Principles:
..................................................
 
OO Principles:

1.Abstraction
2.Encapsulation
3.Typing
     ->Polymorphism
4.Modularity
    ->packages
5.Hierachy
   -is-a : inheritance
   -has-a
-------------------
6.Concurrency

7.Persistency

if any pl follows first principle, those languages are called object oriented pl.

if any language does not implement 5 principles fully, or partially implements those
languages are called as "Object Based Programming language"

//////////////////////////////////////////////////////////////////////////////////////////

What is Object?

  Memory, having state and behaviour.

How do you create object?

In classical object oriented pl, class is fundamental unit to create object.

In javascript by default no classes : class free object based language, in es 6 , who 
added class syntax.

In javascript how to create objects?

Patterns:

1.constructor pattern
  ->functions
  ->es 6 class
2.literal pattern
  -no class,no function.

Object charactertics:

1.state : data: instance variables
2.indentity  : data :	 instance variable
3.behaviour : methods

how to declare instance variables and methods?

 ->this keyword


function as object template:

Coding standards:

1.if function is going to hold logic then function name should be
  verb or verbNoun
  add() , calculateInterest()

2.if function is going to hold object data, function name should be
  Noun
  Employee,Customer,Invoice,Order,Product....


//Object template : class
function Employee() {
    //instance variables
    this.id = 1;
    this.firstName = 'Subramanian'
    this.lastName = 'Murugan'
    //instance methods
    this.calculateSalary = function () {
        return 1000;
    };
}

//object creation
let emp = new Employee();
//access object properties:variables and methods
console.log(`Id ${emp.id}`);
console.log(`Name ${emp.firstName} ${emp.lastName}`);
console.log(`Salary ${emp.calculateSalary()}`);

here emp : it is just variable we call as reference variable
let is keyword
new is keyword to create object
Employee() -> function call with respect to Object : constructor call.


ES 6 classes:

/Syntax Sugar for function object template : class
class Customer {
    //instance variables
    id = 1;
    firstName = 'Subramanian'
    lastName = 'Murugan'
    //methods
    calculateInvoice() {
        return 1000
    }
    calculateGST = () => 1000;
}
let cust = new Customer();
//access object properties:variables and methods
console.log(`Id ${cust.id}`);
console.log(`Name ${cust.firstName} ${cust.lastName}`);
console.log(`Invoice ${cust.calculateInvoice()} ${cust.calculateGST()}`)


Literal pattern:

let product = {
    id: 1,
    name: 'Iphone',
    price: 10000,
    qty: 100,
    //methods
    calculateQty: function () {
        return 10 * 90;
    },
    calculateGST() {
        return 10;
    },
    calculateStock : () => 1000
};

console.log(`Product info`)
console.log(`Id ${product.id}`);
console.log(`name ${product.name}`);
console.log(`price ${product.price}`);
console.log(`qty ${product.qty}`);
console.log(`Stock ${product.calculateStock()}`);

///////////////////////////////////////////////////////////////////////////////////////////

How to initalize state?

state can be initalized in three ways

1.direct /hardcoded way
2.after object creation
3.during object creation.



1.direct /hardcoded way

function Employee() {
    //instance variables
    this.id = 1;
    this.firstName = 'Subramanian'
    this.lastName = 'Murugan'
 }
class Customer {
    //instance variables
    id = 1;
    firstName = 'Subramanian'
    lastName = 'Murugan'
}

let product = {
    id: 1,
    name: 'Iphone',
    price: 10000,
    qty: 100,
};


2.after object creation
//Object template : class :es 5
function Employee() {
    //instance variables
    this.id = 1;
    this.firstName = 'Subramanian'
    this.lastName = 'Murugan'
    //instance methods
    this.calculateSalary = function () {
        return 1000;
    };
}

//object creation
let emp = new Employee();
//initalize the object properties after object creation

emp.id =100;
emp.firstName = 'Srisha'
emp.lastName = 'Subramanian';


//access object properties:variables and methods
console.log(`Id ${emp.id}`);
console.log(`Name ${emp.firstName} ${emp.lastName}`);
console.log(`Salary ${emp.calculateSalary()}`);

class Customer {
    //instance variables
    id = 1;
    firstName = 'Subramanian'
    lastName = 'Murugan'
    //methods
    calculateInvoice() {
        return 1000
    }
    calculateGST = () => 1000;
}
let cust = new Customer();

//initalize the object properties after object creation
cust.id =9999;
cust.firstName ='Ram';
//access object properties:variables and methods
console.log(`Id ${cust.id}`);
console.log(`Name ${cust.firstName} ${cust.lastName}`);
console.log(`Invoice ${cust.calculateInvoice()} ${cust.calculateGST()}`)

let product = {
    id: 1,
    name: 'Iphone',
    price: 10000,
    qty: 100,
    //methods
    calculateQty: function () {
        return 10 * 90;
    },
    calculateGST() {
        return 10;
    },
    calculateStock : () => 1000
};

console.log(`Product info`)
product.id =99999;
product.name ='Lenvo Think Pad',
product.qty =90;


console.log(`Id ${product.id}`);
console.log(`name ${product.name}`);
console.log(`price ${product.price}`);
console.log(`qty ${product.qty}`);
console.log(`Stock ${product.calculateStock()}`);

3.during object creation : constructor over loading

//Object template : class :es 5
function Employee(id = 1, firstName = 'Subramanian', lastName = 'Murugan') {
    //instance variables
    this.id = id;
    this.firstName = firstName
    this.lastName = lastName
    //instance methods
    this.calculateSalary = function () {
        return 1000;
    };
}

//object creation

let emp = new Employee(1, 'Subramanian', 'Murugan');

//access object properties:variables and methods
console.log(`Id ${emp.id}`);
console.log(`Name ${emp.firstName} ${emp.lastName}`);
console.log(`Salary ${emp.calculateSalary()}`);

class Customer {
    //instance variables
    constructor(id = 1, firstName = 'Subramanian', lastName = 'Murugan') {
        this.id = id;
        this.firstName = firstName;
        this.lastName = lastName
    }

    //methods
    calculateInvoice() {
        return 1000
    }
    calculateGST = () => 1000;
}
let cust = new Customer(1, 'Subramanian', 'Murugan');
//access object properties:variables and methods
console.log(`Id ${cust.id}`);
console.log(`Name ${cust.firstName} ${cust.lastName}`);
console.log(`Invoice ${cust.calculateInvoice()} ${cust.calculateGST()}`)

////////////////////////////////////////////////////////////////////////////////////////////

Hierachy: Object Relation ship

1.is-a 
2.has-a 

IS-A : Inheritance

inheritance in es 5 , so complex: proto types:
 https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Inheritance

is-a in es 6 : looks like java.

inheritance objective : code sharing in parent and child relationship.


super keyword


class Account {
    constructor(accountId) {
        console.log('Account class')
        this.accountId = accountId;
    }
    withdraw(){
        console.log('withdraw in account')
    }
}
class SavingsAccount extends Account {
    constructor(accountId) {
        super(accountId)
        console.log('SavingsAccount class')
    }
    //Redefining: not overriding
    withdraw(){
        super.withdraw()
        console.log('withdraw in SavingsAccount')
    }
}

//object creation
let account = new SavingsAccount(233);
console.log(account.accountId)
account.withdraw();

//////////////////////////////////////////////////////////////////////////////////////////

HAS-A : Dependency Injection:
..............................

done through only constructor.


//using functions
/**function Product(pid = 'P001', name = 'Iphone') {
    this.pid = pid;
    this.name = name;
}
function Order(orderId = 'A001', product = new Product()) {
    this.orderId = orderId;
    //HAS-A
    this.product = product;
}**/
//using classes
class Product {
    constructor(pid = 'P001', name = 'Iphone') {
        this.pid = pid;
        this.name = name;
    }
}
class Order {
    constructor(orderId = 'A001', product = new Product()) {
        this.orderId = orderId;
        //HAS-A
        this.product = product;
    }
}
//create object with dependencies

let product = new Product();
let order = null;

order = new Order();
console.log(`OrderId ${order.orderId} ${order.product.pid} ${order.product.name}`)

order = new Order('B002', product);
console.log(`OrderId ${order.orderId} ${order.product.pid} ${order.product.name}`)

order = new Order('B002', new Product('P8880', 'Lenvo Think Pad'));
console.log(`OrderId ${order.orderId} ${order.product.pid} ${order.product.name}`)



//has-a with literal objects: nested object

let locationInfo = {
    country: {
        countryName: 'INdia',
        state: {
            stname: 'Tamil Name',
            district: {
                name: 'Coimbatore'
            }
        }
    }
}
console.log(locationInfo.country.state.district.name)

////////////////////////////////////////////////////////////////////////////////////////////

Object internal structure:

ASYNC programming

scope chain

What is async/sync  programming?

Sync programming : sequential execution


Javascript engine archiecture : V8


What is javascript engine/runtime?

 It is program written in c / c++ /any language.
 v8 is c++ program written by google, used inside chrome and nodejs

Program  : collection of instructions

Types of Program:

1.passive program
   The program which is not in ram or which is in hard disk or the program which is not accessed by CPU.

2.Active program
  The program which is in ram, which is accssed by cpu :  Process.

Process: Program in execution

eg:

 v8 which is hard disk
  when you run/execute
  v8 is moved from harddisk to ram :  Process.


Note: Any process on any os, has structure : process layout / memory layout,
  any thing if you move on ram, will have common structure.


Process layout:

1.heap
2.stack
3.Program data



source code : index.js

 Steps 

0.Loading

    The process of reading source code from local disk or from remote machine via networks

1.compilation
   Javascript engine has in built compiler(Parser-Lexical parser)

compiler ;
 Hello.java ---javac ---- Hello.class(assembly)-----feed into runtime--->Exection
 
Parser:
 index.js----parser--->breaks javascript into string tree--->feed into runtime---> convert
 tree into assembly instruction--->execution


2.Execution
 tree into assembly instruction--->execution
 memory allocation happens for our code.


How execution begins?

 Any language , execution begins from main method.
 
Does js has main method?
  
  Yes!, which is supplied by runtime.



index.js

function sayHello(){
     console.log('hello')
}
function sayHai(){
  console.log('hai');
}

sayHello();
sayHai();
   |

 parser
   |

 parsed program
   |
 Execution
   |
  main function
   |
 sayHello();---->FUNCTION call should be moved to RAM(MEMORY ALLOCATION FOR function).

Note: if you allocate memory, os will maintain structure.

Where is function is allocated? and what is its structure?

 Function memory is allocated inside "STACK"

function  invocation means, we are pushing function into stack.

 add()------->push---into--stack ------>stack will allocate memory----"Stack Frame"

Stack frame:

 contains
 local variables
 return address

once frame is completed its operation, then will be removed from main memory.

all functions are pushed and pop sequencially : Sync Programming.


Threads:
 What is thread?

  A stack frame is called "thread".


If you are running more than one stack frame at the same time, we call "Multi threading".

Yes ,we can have multi threading :Concurrency.

Java and other languages support multi threading

Javascript engine never support multi threading. only one frame only we can run.: Single Threaded.

//sync

function add(){
   let result = 10 + 10;
}

function sayHello(){
     console.log('hello')
}
function sayHai(){
  console.log('hai');
}

add();//---pushed into stack--frame is created--running-completed
sayHello();//---pushed into stack--frame is created--running-completed
sayHai();//---pushed into stack--frame is created--running-completed



Use case : what if a frame is running long long time. 
  eg: 
   a function which connects network socket, getting 1 million data, fromating data.

during that time, what will happen to rest of the Program?

       "Blocking State" : Application will be blocked until, the frame is removed memory.

Lets imagine , you have executed js code inside browser, one function halts the entire browser
to continue.


What is the solution js offers inside of multi threading?

 Yes! : Async Programming : Another way of achiving concurrency.


What is node js?
       NonBlocking,Async Platform 



NonBlocking/Async/  Architecture:

 This is not only for node js 

 Async architecture is designed based on one design pattern "Reactor Design Pattern"


 1. worker - thread model
   The main process (Node/Browser)never creates stack frame(thread) rather than it will
  move the control to os kernal space.

 2.Events - Event Driven Programming
    Signal : completed,connected,closed......

 3.Handler function : callbacks
    The function which has been assigned for handling results.

 4.Event Queue(Task Queue)
    It is data structure which has completed job references in the form of functions
    - callback functions

 5.Event loop
    It is program which keeps on checking the queue whether any message should be
   processed : for what , in order to send results back to clients.

 Event loop can push callbacks into stack only if "stack is empty"
   
..........................................................................................

 api---push--javascript engine--stack----delagate to os kernal--- keeps on runnning on os kernal-- once done--kernal gives signal to javascript engine--- queue---event loop process the first message --if stack is empty--push that handler function to stack---stack will process the frame-result is returned to client.

/////////////////////////////////////////////////////////////////////////////////////////////

Async Programming and implemenation:
....................................

Note: dont create frames for any complex task.


Rules /Steps:

1.any async operation must be handed to libuv(Which is low level c program bundled with node distribution).
  lets say add function can it be async ?
   no: add has no eq low level api.

What are low level apis?

 Browser:
    timers
 setTimeout
 xhr: ajax : network api
 .....

 Node :
   timers
  setTimeout   
  .....

2.function should be passed as parameter : callbacks : Queue Message

............................................................................................

Progamming Implementation:

1.callback pattern
2.Promise
3.async await
4.Generators   



callbacks:

1.timers



The async code:

//Async implementation Using timer
function sayGreeter(handler) {
 //Delegate to kernal /os
 setTimeout(function(){
     handler();
 },1000);
}

function add(a, b) {
    return a + b;
}

sayGreeter(function(){
    console.log(' i wil be called late')
});//pushed into stack--settimeout---delegate to os---timer is 
 //ticking--|control is released starts execution next line --timeout----
   //--->signal "wake up"---node stores message in the event queue--loop--pick up message from
// event queue-- check whether stack is empty----push that handler into stack--display message
 //"i will be called late"
console.log(add(10,10));

//////////////////////////////////////////////////////////////////////////////////////////////

Callbacks:

  call - invoke
  back - future

callback pattern is core pattern for async programming.

callback programming and its complexcity ::"Callback hell"


Objective:
  "The result(output) of one async operation , will be input to the next operation"

//callback hell
const getUser = (success, failure) => {
    //fake data
    let user = {
        id: 1,
        name: 'admin',
        password: 'admin'
    };
    //let user = null;
    if (user) {
        setTimeout(() => success(user), 1000);
    } else {
        setTimeout(() => failure({ err: 'User Not found' }))
    }
};

const login = (user, success, failure) => {
    //biz logic
    if (user.name === 'admin') {
        setTimeout(() => {
            success({ status: 'Login Success' })
        })
    } else {
        setTimeout(() => {
            failure({ status: 'Login failed' })
        })
    }
};

//two callback functions
//getUser(user => console.log(user), err => console.log(err));

//with input to login functon
getUser(user =>
    login(user, authInfo => console.log(authInfo), err => console.log(err)),
    err => console.log(err));



Questions:

1.Whether this is able to understand quickly
2.Whether this code is able to debug
3.Whehter this code is scalable?
4.whether this code is maintaiable?

  "No" : This is what we call as "Callback hell".

fs.readdir(source, function (err, files) {
  if (err) {
    console.log('Error finding files: ' + err)
  } else {
    files.forEach(function (filename, fileIndex) {
      console.log(filename)
      gm(source + filename).size(function (err, values) {
        if (err) {
          console.log('Error identifying file size: ' + err)
        } else {
          console.log(filename + ' : ' + values)
          aspect = (values.width / values.height)
          widths.forEach(function (width, widthIndex) {
            height = Math.round(width / aspect)
            console.log('resizing ' + filename + 'to ' + height + 'x' + height)
            this.resize(width, height).write(dest + 'w' + width + '_' + filename, function(err) {
              if (err) console.log('Error writing file: ' + err)
            })
          }.bind(this))
        }
      })
    })
  }
})

callback hell is other wise called as doom of pyrbid.


///////////////////////////////////////////////////////////////////////////////////////////

How to write better callback programming? or How to avoid callback hell?


In 2005, JQUERY team started with working complex callback patterns, they found callback
hell problem.

They proposed a  Design pattern to write better callback programming(Async) programming.

  "Promise".


Promise is design pattern which hides complexity of callback patterns


SInce Promise is design pattern, many people have implemented Promise design pattern.

1.JQuery -first promise implementation
2.many libs and frameworks

2012 E6 Commit introduced Promise as Object in javascript


features of Promise Object:

1.Promise by deafult is Async. Which implements timer api with 0 ms .

Promise can be used with any async implementations.

Promise Implemenation:

1. Create Promise Object from Promise contructor
2. Create PRomise object from factory apis 

Promise object methods:
1.then - success
2.catch - errors
3.finally - clean up
4.resolve
5.reject
6.all
7.race

Lets code using Promise

Promise Object creations:

1.factory apis.
 resolve
 reject
 both

//Promise 

//success : resolve

const getValue = () => {
    return Promise.resolve('I am delayed using promises') // 
    //which returns Promise object with data
};
const getError = () => {
    return Promise.reject('Something went wrong!');
}

//Promise with resolve and reject ; with biz logic
const getUser = () => {
    let user = {
        id: 1,
        name: 'admin',
        password: 'admin'
    };
    //let user = null;
    if (user) {
        return Promise.resolve(user);
    } else {
        return Promise.reject('user not  found!!');
    }
}


console.log('start')
// let p = getValue();
// //how to process result: then
// p.then(value => console.log(value));

// let ep = getError();
// ep.catch(err => console.log(err));
//code refactoring using builder pattern
getValue()
    .then(value => console.log(value))
    .finally(() => console.log('done'));

getError()
    .catch(err => console.log(err))
    .finally(() => console.log('done'));

getUser()
    .then(user => console.log(user))
    .catch(err => console.log(err))
    .finally(() => console.log('user api done'));

console.log('end')
///////////////////////////////////////////////////////////////////////////////////

Promise Objects via Constructors:

 new Promise((resolve,reject)=>{
 
   //biz logic
  
 });


const getUser = () => {
    let user = {
        id: 1,
        name: 'admin',
        password: 'admin'
    };
    return new Promise((resolve, reject) => {
        if (user) {
            //timer ; callback based
            //timer result wrap inside promise
            setTimeout(() => {
                resolve(user);
            }, 1000);
        } else {
            setTimeout(() => {
                reject('Something went wrong');
            }, 1000);
        }
    });
}
getUser()
    .then(user => console.log(user))
    .catch(err => console.log(err))
    .finally(() => console.log('user api done'));

//////////////////////////////////////////////////////////////////////////////////////////

Promise chaining: Nested Promises : Promise Hell:
.................................................

The output of one promise , will be input into another promise: similar to callback nesting.



const getUser = () => {
    let user = {
        id: 1,
        name: 'admin',
        password: 'admin'
    };
    return new Promise((resolve, reject) => {
        if (user) {
            //timer ; callback based
            //timer result wrap inside promise
            setTimeout(() => {
                resolve(user);
            }, 1000);
        } else {
            setTimeout(() => {
                reject('Something went wrong');
            }, 1000);
        }
    });
}


const login = user => {
    return new Promise((resolve, reject) => {
        if (user.name === 'admin') {

            setTimeout(() => {
                resolve('Login success');
            }, 1000);
        } else {
            setTimeout(() => {
                reject('Login failed');
            }, 1000);
        }
    });
}



getUser()
    .then(user =>
        login(user) //output of getuser will be input to login
    )
    .then(loginstatus => console.log(loginstatus))
    .catch(err => console.log(err))
    .finally(() => console.log('user api done'));



Promise Hell: Promise has limitions;
......................

1.Promise is still  complex when you start scalling complex async operations.

2.Which is not readable ,which uses lot of then, catch blocks

In order to write even simple complex async work flows ES 7 introduced
a concept called "async await" keywords


 It is simplest pattern of Promises.
 It is promise driven only.

          "Sync style of Async Code" 

async key must be used with function declaration.
await is used to pause async calls


async function:

by default which returns promise object what ever you return.
 

//simple async function : by default async funciton return Promise

async function getValue() {
    return 100;  // Promise.resolve(100);
}
async function getError() {
    return Promise.reject('error')
}
async function getUser() {
    let user = {
        id: 1,
        name: 'admin',
        password: 'admin'
    };
    //let user = null;
    if (user) {
        return user;
    } else {
        return Promise.reject('user not  found!!');
    }
}
getValue()
    .then(user => console.log(user))
    .catch(err => console.log(err))
    .finally(() => console.log('value done'));

getError()
    .catch(err => console.log(err))
    .finally(() => console.log('error done'));

getUser()
    .then(user => console.log(user))
    .catch(err => console.log(err))
    .finally(() => console.log('user api done'));


////////////////////////////////////////////////////////////////////////////////



function getUser() {
    let user = {
        id: 2,
        name: 'admin'

    }
    if (user) {
        return Promise.resolve(user)
    }
    else {
        return Promise.reject('User not found')
    }
}

function login(user) {
    if (user.name === 'admin') {
        return Promise.resolve('Login success')
    }
    else {
        return Promise.reject('Login failed')
    }
}

//old promise style
// function fetch() {
//     getUser().then(value => console.log(value));
// }
//async await style
async function fetch() {
    try {
        const user = await getUser();
        const status = await login(user);
        console.log(`${user.name} ${status}`);
    }
    catch (err) {
        console.log(err)
    }
}
fetch();
//////////////////////////////////////////////////////////////////////////////////////////

TodoService app with promise,async,await
.......................................
const { findAll } = require('./services/TODOService');

//front end api

async function getTODOS() {
    // findAll().forEach(todo => {
    //     console.log(`User id : ${todo.userId} `)
    //     console.log(`title : ${todo.title}`);
    //     console.log(`Status : ${todo.completed ? 'Completed' : 'NotCompleted'} `)
    // });
    //callback based api
    // findAll(todos => {
    //     todos.forEach(todo => {
    //         console.log(`User id : ${todo.userId} `)
    //         console.log(`title : ${todo.title}`);
    //         console.log(`Status : ${todo.completed ? 'Completed' : 'NotCompleted'} `)
    //     });
    // });

    try {
        const todos = await findAll();
        todos.forEach(todo => {
            console.log(`User id : ${todo.userId} `)
            console.log(`title : ${todo.title}`);
            console.log(`Status : ${todo.completed ? 'Completed' : 'NotCompleted'} `)
        });
    }
    catch (err) {
        console.log(err);
    }
}
console.log('start')
getTODOS();
console.log('end');
    try {
        const user = await getUser();
        const status = await login(user);
        console.log(`${user.name} ${status}`);
    }
    catch (err) {
        console.log(err)
    }
}
fetch();

    const TODOS = require('../mock-data/todo-mock');

    class ToDoService {
        constructor() {

        }
        //sync : convert this as async
        // findAll() {
        //     return TODOS;
        // }
        //findAll async version : callbacks
        // findAll(callback) {
        //     setTimeout(() => {
        //         callback(TODOS)
        //     }, 1000);
        // }
        //Promise powered
        findAll() {
            return new Promise((resolove, reject) => {
                setTimeout(() => {
                    resolove(TODOS)
                }, 1000);
            });

        }
    }
    module.exports = new ToDoService();

////////////////////////////////////////////////////////////////////////////////////////////

Node js : io : fs io , web programming
.....................................

Node was created to do nonblocking io.

Types of modules:
 
1.node in built modules

2.custom modules
3.third party modules


1.node in built modules


1.os module
2.events module
3.file system module
4.path
5.http module


2.os module provides 
The os module provides operating system-related utility methods and properties.

//os module
const os  = require('os');

console.log('Total CPUs')
console.log(os.cpus());
console.log('Arch ',os.arch())


./ vs ''
.........

 require('./services/TODOService');
  ->here you can see ./
  ./ -current dir
 require('os'); => 
  -here no ./ 


Why?

Note : if you are java devp, you know the classpath , how it works?


require('os');

Node internally uses a search algorthim,node always looks the folder called
 "node_modules" in the current project, if not , then it searches, the node in built 
installtion folder---c:/pf/node/node_nodules--if it finds it will pick up from there else it will throw error.

require('./services/TODOService');
   it will lookup in the current dir or sub dirs only.

/////////////////////////////////////////////////////////////////////////////////////////////

Event Emitter Modules:


 It is used to build driven programming.
 In node js most io applications are event driven.

All event driven architectures are based on pub-sub pattern

1.publisher
2.subscriber


const EventEmitter = require('events');


//domain object is powered with event emitter pattern
class ProductService extends EventEmitter{
     constructor(){
         super();
         this.on('sold',(product)=>{
             console.log(`Product has been sold`);
         });
     }
     //biz api
     sale(product){
         this.emit('sold',product);
     }
}

module.exports = ProductService;

const EventEmitter = require('events');
const ProductService = require('./services/ProductService');

//create Object for event emitter
const eventEmitter = new EventEmitter();

//subscriber
eventEmitter.on('hello', function (data) {
    console.log(`${data}`);
});

//publisher
eventEmitter.emit('hello', 'Hello How are you!');
eventEmitter.emit('hello', 'Wow!..');

//sale 
let pService = new ProductService();
pService.sale({ id: 1, name: 'Phone' });

/////////////////////////////////////////////////////////////////////////////////////////////

How to write async or non blocking programming?


Requirements to write async code?

1.You must have low level async api and eq high level async api
2.handler function / callback function : function as param.

api for async code: in node

1.timers
2.non blocking io apis
  -fs,http,ftp.....

1.fs io
2.network io
  -http : web apps


File System : fs

 To read , Write disk files

const fs = require('fs');

//fs.readFile(path[, options], callback)

const path = "./src/assets/info.txt";
const options = {
    encoding: 'utf-8'
};
console.log('start')
fs.readFile(path, options, function (err, data) {
    if (err) throw err;
    console.log(data);
});
console.log('end');
////////////////////////////////////////////////////////////////////////////////////

The above code uses full file path , i dont want to use full file path?

Global Objects in node:

1.process
2.JS objects-math,date....
3.exports
4.module

Global Variables:

5.__dirname
      ->Get current dir path
6.Global Objects in node:

1.process
2.JS objects-math,date....
3.exports
4.module
5.__dirname
      ->Get current dir path
6.__filename
     ->Get current dir + path__filename
     ->Get current dir + path


Use Case:
  current dir + fileName
	dir/src + fileName


How to get full file path through code?

Path Module:
-----------
The path module provides utilities for working with file and directory paths.


const fs = require('fs');
const path = require('path');

//const path = "./src/assets/info.txt";
const filePath = path.join(__dirname, "assets/info.txt");
const options = {
    encoding: 'utf-8'
};
console.log('start')
fs.readFile(filePath, options, function (err, data) {
    if (err) throw err;
    console.log(data);
});
console.log('end');

/////////////////////////////////////////////////////////////////////////////////////////
//write file
const fs = require('fs');
const path = require('path');

//fs.writeFile(file, data[, options], callback)
const filePath = path.join(__dirname, "assets/info_copy.txt");
const options = {
    encoding: 'utf-8'
};
const data = "Hello I am node file !!!!!!";;
fs.writeFile(filePath, data, options, function (err) {
    if (err) throw err;
    console.log(filePath, 'has been written')
});
//////////////////////////////////////////////////////////////////////////////////

Does node supports blocking io? , node itself handles io operation instead of os?

 Yes! but dont over use, which blocks current stack.


How nodes supports blocking io?

  Thread pools

const fs = require('fs');
const path = require('path');

//const path = "./src/assets/info.txt";
const filePath = path.join(__dirname, "assets/info.txt");
const options = {
    encoding: 'utf-8'
};
//sync read file
//fs.readFileSync(path[, options])
console.log('start')
const data = fs.readFileSync(filePath, options);
console.log(data);
console.log('end');

////////////////////////////////////////////////////////////////////////////////////////////

IO operations can be done sync or async way.

Async io operations can be done two ways.

1.Non-Streaming
2.Streaming  : Evented IO : Event driven IO.


Non Streaming IO : read / write

The operating system completes the whole file read operation, sends to node process memory  , and finally will be delivered to user

in concurrent env , if you read and load more files on node process,node process will crash.

What is the solution:

1.Streaming :

node breaks content into smaller unit called "chunk"
node streams /send data in order chunk by chunk.


Non streaming apis : dont use for big file reading in network env
fs.readFile,fs.writeFile

Types of Streams:

1.Readaable Stream : input
2.Writeable stream : output
3.Duplex stream : read + output


Built in readable Streams:

HTTP responses, on the client
HTTP requests, on the server
fs read streams
zlib streams
crypto streams
TCP sockets
child process stdout and stderr
process.stdin

Writable Streams:
HTTP requests, on the client
HTTP responses, on the server
fs write streams
zlib streams
crypto streams
TCP sockets
child process stdin
process.stdout, process.stderr


All streaming apis are powered with events
node io streams has built in events.
events are emitted by os
Our programs are listeners.

common events in all io

data event:
 which is emitted by node, for each chunk.

close event:
The 'close' event is emitted when the stream and any of its underlying resources (a file descriptor, for example) have been closed.

end event:
The 'end' event is emitted when there is no more data to be consumed from the stream.

Event: 'error'
 The 'error' event may be emitted by a Readable implementation at any time
Typically, this may occur if the underlying stream is unable to generate data due to an underlying internal failure, or when a stream implementation attempts to push an invalid chunk of data.

How to read file using streaming mode?


const fs = require('fs');
const path = require('path');

//const path = "./src/assets/info.txt";
const filePath = path.join(__dirname, "assets/big.file");
const options = {
    encoding: 'utf-8'
};

//create read stream

const inputStream = fs.createReadStream(filePath,options);

//add events for listensing
let data = '';
inputStream.on('data', function (chunk) {
      console.log(`Received ${chunk.length} bytes of data.`);
      data += chunk;

});

//end event
inputStream.on('end', function () {
      console.log('There will be no more data to read!');
      //console.log(data);
})

//error event: for error handling
inputStream.on('error', function (err) {
      console.log(`Some thing went wrong! ${err}`)
});

///////////////////////////////////////////////////////////////////////////////////////////

Write Stream:
.............

const fs = require('fs');
const path = require('path');

const fileName = path.join(__dirname, 'assets/grains.txt');
const config = {
    encoding: 'utf8',
    flag: 'w'
};
//data
const grains = ['wheat', 'rice', 'oats'];

const outputStream = fs.createWriteStream(fileName, config);

while (grains.length) {
    let data = grains.pop() + " ";
    outputStream.write(data);
    console.log("Wrote: %s", data);
}
//call close method : will trigger close 
outputStream.close();

outputStream.on('close', function () {
    console.log('file stream has been closed!!')
})

////////////////////////////////////////////////////////////////////////////////////////////

file Move operations : read + write together:
.............................................

//read + write 
const fs = require('fs');
const path = require('path');

const fileName = path.join(__dirname, 'assets/info.txt');

const config = {
    encoding: 'UTF-8'
}

const outputFileName = path.join(__dirname, 'assets/greeter.txt');


const inputStream = fs.createReadStream(fileName, config);

const outputStream = fs.createWriteStream(outputFileName, config);

//Register data event.
inputStream.on('data', function (chunk) {
    console.log(`Received ${chunk.length} bytes of data.`);
    console.log(chunk);
    outputStream.write(chunk);
});


//end event
inputStream.on('end', function () {
    console.log('There will be no more data to read!');
    outputStream.close();
})

//error event: for error handling
inputStream.on('error', function (err) {
    console.log(`Some thing went wrong! ${err}`)
});

outputStream.on('close', function () {
    console.log(`File write operation is completed`);
});

/////////////////////////////////////////////////////////////////////////////////////////

Back Pressure:
..............

If you want to read data from one file and write into anthoer file.
If you want to read data from network sockets and write into anthoer file /another socket.

Read + Write => togther
Eg:
 copy and paste
 file moving 
 file copies

Problems when you do read and write together

1. In general read operation is faster than write operation

Back Pressure means inputstream is fast, outputstream slow, then data will be lost.


Handling back pressure:
.......................
Pause Input stream if the Node Process memory is full(Buffer),resume if buffer/process memory is empty.

stream.pause() if stream is full
else
stream.resume() if stream is drain

//back pressure
const fs = require('fs');
const path = require('path');

const inputfileName = path.join(__dirname, 'assets/big.file');
const outputfileName = path.join(__dirname, 'assets/big_copy.file');

const config = {
      encoding: 'UTF-8'
}

//Back pressure handling
const readerStream = fs.createReadStream(inputfileName, config);
const writeStr = fs.createWriteStream(outputfileName, config);

readerStream.on('data', function (chunk) {
      console.log(`Received ${chunk.length} bytes of data.`);
      let buffer_good = writeStr.write(chunk);
      if (!buffer_good) readerStream.pause();
});
writeStr.on('drain', function () {
      console.log('buffer drained!');
      readerStream.resume();
});

readerStream.on('end', function () {
      //console.log(data);
});

readerStream.on('error', function (err) {
      console.log(err.stack);
});
////////////////////////////////////////////////////////////////////////////////////

How to handle back pressure using very simple api 

 inputstream.pipe(outstream); // will transfer files with back 



const fs = require('fs');
const path = require('path');

const inputfileName = path.join(__dirname, 'assets/big.file');
const outputfileName = path.join(__dirname, 'assets/big_copy.file');

const config = {
      encoding: 'UTF-8'
}

//Back pressure handling
const readerStream = fs.createReadStream(inputfileName, config);
const writeStr = fs.createWriteStream(outputfileName, config);

//backPressure streams
//pipe method is simplest method which wraps resume,pasuse,drain 
readerStream.pipe(writeStr);


Quiz:

Create FileService class 

have read method
 inside read method implement file operations, wrap inside promise return promise

in main program use async await keywor to read file content.

/////////////////////////////////////////////////////////////////////////////////////////

Web Programming : how to create webserver and web application using node http io module
///////////////////////////////////////////////////////////////////////////////////////

Web Apps in Node:
................

Tradtional web work flow

Client-----request----------------WebServer--- thread--will io operation.
Client-----request----------------WebServer----thread--will io operation.
Client-----request----------------WebServer---thread-- will io operation.
Client-----request----------------WebServer---thread-- will io operation.



Non Blocking web model(Node.js):
...............................

Client-----request------WebServer built by node---|-            will io operation.
Client-----request------WebServer built by node---|- libvu --os will io operation.
Client-----request----- WebServer built by node---|-            will io operation.
Client-----request----- WebServer built by node---|-            will io opeeration


node and http 
node provides http high level api from 'http.js' through module.


//create web server
//create web app

//start the webserver


class:http:ServerResponse : output
class:http:ClientRequest : input
class:http:Server : handling low socket operations


const http = require('http');

const port = 3001;

//create server
const server = http.createServer(function (req, res) {
    res.write('<h1>Welcome to node application</h1>')
    res.end();
});

//deploy app and start server

server.listen(port, function () {
    console.log('Server startup done!')
});


////////////////////////////////////////////////////////////////////////////////////

How to attach events on server?


//how to add events 

const http = require('http');

const port = 3001;

//create server
const server = http.createServer(function (req, res) {
    res.write('<h1>Welcome to node application</h1>')
    res.end();
});

//deploy app and start server

server.listen(port, function () {
    console.log('Server startup done!')
});

//add events for servers
server.on('request', function (request, response) {
    console.log(`Request received ${new Date()}`)
});
/////////////////////////////////////////////////////////////////////////////////////////////
How to handle incomings / how to data from the client?


const http = require('http');

const port = 3001;

//create server
const server = http.createServer(function (req, res) {

    //data from client
    req.on('data', function (chunk) {
        console.log(chunk.toString());
    });
    req.on('end', function () {
        res.write('<h1>Welcome to node application</h1>')
        res.end();
    });

});

//deploy app and start server

server.listen(port, function () {
    console.log('Server startup done!')
});

//add events for servers
server.on('request', function (request, response) {
    console.log(`Request received ${new Date()}`)
});

///////////////////////////////////////////////////////////////////////////////////////

How to build REST End points?

HTTP Verbs : GET,POST,PUT,DELETE...
RESOURCE URLS : /api/users  /api/products /api/products/1


GET /api/users ==> USERS AS JSON

CAN YOU USE HTTP Module to build realtime rest points?

  Yes! but it is diffcult to build , why because , we dont have proper design patterns
or no boiler plate code.


Then we need to use frameworks.
 -Express js.

////////////////////////////////////////////////////////////////////////////////////////

NPM:

node modules types
1.custom module - discussed
2.in built modules - disucssed
3.third party modules - 

npm:   
 node package manager === mvn
npm is tool is used to distribute node modules to others
and you can get node modules from  others.

npm tool is distributed along with node installation

npm uses public repository server called npmjs.com npmjs.org

tools and libs,frameworks all are distributed as node modules into repository.


Javascript Project Structure:(server side/ client side)
.........................................................

The project must have two things

1.package.json file :
   meta file which describes the project information
2.node_modules folder
   which contains libs/frameworks/tools code.


create package.json file

>npm init


{
  "name": "mynode-apps",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "Subramanian Murugan",
  "license": "ISC"
}


npm is used

to install,uninstall,publish node modules from node repo / into node repo.

if you install third party modules , into your project, node distributes npm tool ,using this you can install,uninstall,upgrade node modules.


npm syntax:

npm commandName.

where <command> is one of:
    access, adduser, audit, bin, bugs, c, cache, ci, cit,
    clean-install, clean-install-test, completion, config,
    create, ddp, dedupe, deprecate, dist-tag, docs, doctor,
    edit, explore, fund, get, help, help-search, hook, i, init,
    install, install-ci-test, install-test, it, link, list, ln,
    login, logout, ls, org, outdated, owner, pack, ping, prefix,
    profile, prune, publish, rb, rebuild, repo, restart, root,
    run, run-script, s, se, search, set, shrinkwrap, star,
    stars, start, stop, t, team, test, token, tst, un,
    uninstall, unpublish, unstar, up, update, v, version, view,
    whoami

node_modules : folder which can hold all javascript modules downloaded from repo.

installing module:

>npm install  moduleName  --options
>npm i moduleName --options

options:
 --save
 --save-dev
 -g

Development

Production

if you are installing any node module, you can tell, do you want to use only for development
or development + production.

Unit testing libs : Junit.jar===>

 --save = >    development + production
 --save-dev => only for development


Eg:
...

$npm i express --save

$npm uninstall express --save
////////////////////////////////////////////////////////////////////////////////////////////

How to use Express to build rest end points?


Express core concepts:

1.Express Application : collection of many objects
2.Express Modules
3.Express middlewares
4.Express with third party libs.


Application:
The app object conventionally denotes the Express application. 

Create it by calling the top-level express() function exported by the Express module


//////////////////////////////////////////////////////////////////////////////////////////

Simple REST End point:

const express = require('express'); // returns function

const port = 3001;

//Create application Object
const app = express();

//CREATE REST ENDPOINTS

//http verb mapping
app.get('/api/books/list', function (req, res) {
    res.end('<h1>Books Api : GET request</h1>')
});
app.post('/api/books', function (req, res) {
    res.end('<h1>Books Api : POST request</h1>')
});
app.put('/api/books/1', function (req, res) {
    res.end('<h1>Books Api : PUT request</h1>')
});
app.delete('/api/books/1', function (req, res) {
    res.end('<h1>Books Api : DELETE request</h1>')
});
//server startup

app.listen(port, function () {
    console.log('Express server is up!')
});

///////////////////////////////////////////////////////////////////////////////////////

How to build modular domain driven REST end points

src
  routes
     booksroutes.js
     usersroutes.js

 app.js/index.js
   server code

                                                             |---books
ClientRequest-----------------|Webserver(app.js)----Routers--|---users
                                                             |---comments

Application

Router Object
  --en

src/routes/userrouter.js
const express = require('express');

//create Router

const router = express.Router();

//users
router.get('/list', function (req, res) {
    res.end('<h1>USERS Api : GET request</h1>')
});
router.post('/', function (req, res) {
    res.end('<h1>USERS Api : POST request</h1>')
});
router.put('/1', function (req, res) {
    res.end('<h1>USERS Api : PUT request</h1>')
});
router.delete('/', function (req, res) {
    res.end('<h1>USERS Api : DELETE request</h1>')
});

module.exports = router;


/src/routes/bookrouter.js
const express = require('express');

//create Router

const router = express.Router();

router.get('/list', function (req, res) {
    res.end('<h1>Books Api : GET request</h1>')
});
router.post('/', function (req, res) {
    res.end('<h1>Books Api : POST request</h1>')
});
router.put('/1', function (req, res) {
    res.end('<h1>Books Api : PUT request</h1>')
});
router.delete('/1', function (req, res) {
    res.end('<h1>Books Api : DELETE request</h1>')
});

module.exports = router;




src/app.js

const express = require('express'); // returns function
const BooksRouter = require('./routes/booksroutes');
const UserRouter = require('./routes/userrouter');

const port = 3001;

//Create application Object
const app = express();

//bind BooksRouterwith with main Application
app.use("/api/books", BooksRouter);
app.use("/api/users", UserRouter)

//server startup
app.listen(port, function () {
    console.log('Express server With routing is up!')
});
//////////////////////////////////////////////////////////////////////////////////////////

URLS: 
/api/books
/api/books/1

/api/books/1 : Request Parameter
/user/:id

router.get('/:id', function (req, res) {
    const id  = parseInt(req.params.id); //
    res.end(`<h1>Books Api : GET request : ${id}</h1>`)
});

How to send json payload

const express = require('express');
const BOOKS = require('../mock-data/books-mock');

//create Router

const router = express.Router();

router.get('/list', function (req, res) {
    res.json(BOOKS);
});

// /api/books/1
router.get('/:id', function (req, res) {
    console.log(req.params);
    const id = parseInt(req.params.id); //
    res.end(`<h1>Books Api : GET request : ${id}</h1>`)
});
router.post('/', function (req, res) {
    res.end('<h1>Books Api : POST request</h1>')
});
router.put('/1', function (req, res) {
    res.end('<h1>Books Api : PUT request</h1>')
});
router.delete('/1', function (req, res) {
    res.end('<h1>Books Api : DELETE request</h1>')
});

module.exports = router;

//////////////////////////////////////////////////////////////////////////////////////////////

How to read data from Mongo db.

if you want to connect with mongo or any database we need a driver

node community provides lot of drivers

monogojs


const express = require('express');
const BOOKS = require('../mock-data/books-mock');
const mongojs = require('mongojs')


//create Router

const router = express.Router();

//read from mock file
// router.get('/list', function (req, res) {
//     res.json(BOOKS);
// });
//read from mongo db

//db connection code
const db = mongojs('BooksDb')

router.get('/list', function (req, res) {

    //Query records from Mongo db
    const books = db.collection('books');
    books.find(function (err, docs) {
        if (err) throw err;
        res.json(docs);
    })

});

// /api/books/1
router.get('/:id', function (req, res) {
    console.log(req.params);
    const id = parseInt(req.params.id); //
    res.end(`<h1>Books Api : GET request : ${id}</h1>`)
});
router.post('/', function (req, res) {
    res.end('<h1>Books Api : POST request</h1>')
});
router.put('/1', function (req, res) {
    res.end('<h1>Books Api : PUT request</h1>')
});
router.delete('/1', function (req, res) {
    res.end('<h1>Books Api : DELETE request</h1>')
});

module.exports = router;
/////////////////////////////////////////////////////////////////////////////////////////

Middlewares:

Express app architecture:

express has two things
1.URL mapping and request processing : app.get('url')
2.Routers , to create moduels

middlewares:
...........

what is middleware?

 it is utility can be plugged in express application.

Express provides only
1.request and response processing.
2.Routers :in to modules.

Middlewares plugins , which enchance express apps.

req.body : if you want to read data from client

y cant directly, express provides a concept called middlewares.

Rest of application features

1.loggers
2.security
3.database connectivity
3.data formating
4.view engine integration


Types of middlewares
1.custom middlewares
2.third party middlewares

middleware workflows:

client----request---node--server---express application---

			   | ---m1
			   | --m2
	express application| ---m3   ----Request Processing(get,post...)
			   |---m4
			   | --mn


 Note : middleware code is executed before request-response handling

 middlewares are eq "filters" in java

How to attach middleware with application object /Router level?

app.use(middleware) : middleware registeration at app level : global middlewares
router.use(middleware) : middleware registeration at module level


Types of middlewares based on Use:
.................................
Application-level middleware
  middleware attached at application : global middlewares
Router-level middleware
 middleware attached at router level(module) : module specific
Error-handling middleware
 for handling global errors
Built-in middleware
 provided by express itself
Third-party middleware
 provided by others.

Built-in middleware
 provided by express itself

1.body-parser :
  which parses client input data into javascript object

npm install body-parser

const express = require('express'); // returns function
const BooksRouter = require('./routes/booksroutes');
const UserRouter = require('./routes/userrouter');
const bodyParser = require('body-parser');


const port = 3001;

//Create application Object
const app = express();

//Attach body parser middleware
app.use(bodyParser.json());

//bind BooksRouterwith with main Application
app.use("/api/books", BooksRouter);
app.use("/api/users", UserRouter)

//server startup
app.listen(port, function () {
    console.log('Express server With routing is up!')
});

const express = require('express');
const BOOKS = require('../mock-data/books-mock');
const mongojs = require('mongojs')


//create Router

const router = express.Router();

//read from mock file
// router.get('/list', function (req, res) {
//     res.json(BOOKS);
// });
//read from mongo db

//db connection code
const db = mongojs('BooksDb')

router.get('/list', function (req, res) {

    //Query records from Mongo db
    const books = db.collection('books');
    books.find(function (err, docs) {
        if (err) throw err;
        res.json(docs);
    })

});

// /api/books/1
router.get('/:id', function (req, res) {
    console.log(req.params);
    const id = parseInt(req.params.id); //
    res.end(`<h1>Books Api : GET request : ${id}</h1>`)
});
router.post('/', function (req, res) {
    const data = req.body;
    console.log(data)
    res.json(data);
});
router.put('/1', function (req, res) {
    res.end('<h1>Books Api : PUT request</h1>')
});
router.delete('/1', function (req, res) {
    res.end('<h1>Books Api : DELETE request</h1>')
});

module.exports = router;

///////////////////////////////////////////////////////////////////////////////////////////

const express = require('express');
const BOOKS = require('../mock-data/books-mock');
const mongojs = require('mongojs')


//create Router

const router = express.Router();

//read from mock file
// router.get('/list', function (req, res) {
//     res.json(BOOKS);
// });
//read from mongo db

//db connection code
const db = mongojs('BooksDb')

router.get('/list', function (req, res) {

    //Query records from Mongo db
    const books = db.collection('books');
    books.find(function (err, docs) {
        if (err) throw err;
        res.json(docs);
    })

});

// /api/books/1
router.get('/:id', function (req, res) {
    console.log(req.params);
    const id = parseInt(req.params.id); //
    res.end(`<h1>Books Api : GET request : ${id}</h1>`)
});
router.post('/', function (req, res) {
    const data = req.body;
    console.log(data)
    const books = db.collection('books');
    boooks.insert(data, function (err) {
        res.json({ message: 'The record has been inserted' });
    })

});
router.put('/1', function (req, res) {
    res.end('<h1>Books Api : PUT request</h1>')
});
router.delete('/1', function (req, res) {
    res.end('<h1>Books Api : DELETE request</h1>')
});

module.exports = router;

Steps:

1.install mongo community edition
https://docs.mongodb.com/manual/tutorial/install-mongodb-enterprise-on-windows/

2.download some mock data
https://github.com/ozlerhakan/mongodb-json-files

3.create db ,collection

4.download samples data like books db.

//////////////////////////////////////********************/////////////////////////////////

MicroServices on Node JS:
.........................

What is Micro service?

 Micro service is one of software enginerring principle
 to build distributed application.

 Microservice is one of software architecture pattern
 to build distribtued applications

Distributed Applications:

The components(parts) of the application is distributed across different machines. 
They communicate each other to exchange data.

Distributed application dev patterns:
....................................

1.Monolithic architecture
2.Microservice architecture




1.Monolithic architecture

The application is developed and deployed as single Java WAR/EAR/JAR file.
a single directory hierarchy of Rails or NodeJS code

Single dev,testing,deployment.

Draw backs:

1.what if i want to deliver project to end clients module by module at period intervals

2.Vendor lock in
   if you select one technolgy like java /mysql, the whole application must be in java only.
   polyglot not possible.
3.Scalablity 
   If you want dev/enchance your application based on modern biz needs, it is difficult
etc...

Micro service :

 Break the whole application into a separate application

Each application can be develped,tested, deployed separatly 
  Domain driven design : Build application based on domain only not for technology 
  SOLID 
//////////////////////////////////////////////////////////////////////////////////////////

Micro Service :

  As a developer , you have to concentrate lot of things.

1. coding
2. infra structure 
    ->How to manage source code repo :git /svn /bit bucket
    ->How to work with CI/CD 
    ->Deployments
         Dockers,KB....
    ->Communication infra
        ->RPI
        ->Messaging : MOM
	->domain specific : TCP/IP ,HTTP,SMTP
   ->Software Registry
       ->Service registry
       ->Service discovery
   ->API Gateways

   ->Reliability
	->Fallabck
        -circuiteBreaker
Observability /Management
	->Log aggregation	
	Application metrics
	Audit logging
	Distributed tracing
	Exception tracking
	Health check API
	Log deployments and changes

  Security
       token
  Centeralized configuration

  DataBase,Transaction
.................................................................................................

Microservice implementations stack:

Today most of the languges provide ms architecture implemenation.

Java frameworks:

1.Microservices with Spring : Spring Cloud Project
2.Eclipse Vert.x
3.Eclipse MicroProfile
etc....

Javascript frameworks: node based framework

1.Moleculer
2.Seneca
3.nonoservices
//////////////////////////////////////////////////////////////////////////////////////////
                                          Moleculer js
				(Progressive Microservice Framework)

What is Moleculer?

Moleculer is a fast, modern and powerful microservices framework for Node.js.

It helps you to build efficient, reliable & scalable services.

Moleculer provides many features for building and managing your microservices.


//////////////////////////////////////////////////////////////////////////////////////

How to start ?

Create Project:

C:\ibm\ibm-node-ms>mkdir microservice-apps

C:\ibm\ibm-node-ms>cd microservice-apps

C:\ibm\ibm-node-ms\microservice-apps>npm init

C:\ibm\ibm-node-ms\microservice-apps>mkdir services

C:\ibm\ibm-node-ms\microservice-apps> code .

$npm i moleculer --save

//////////////////////////////////////////////////////////////////////////////////////////////

Core concepts in Molecular:
..........................

Service
 A service is a simple JavaScript module containing some part of a complex application. 
 A service represents a biz logic in your application.


Service Broker : == Spring Container
 Service Broker is the heart of Moleculer.

 It is responsible for management and communication between services (local and remote). 
 Each node must have an instance of Service Broker.

  "Service Broker is one single Node instance - Node runtime"




		
		         Service1 -- Service 2 Service N
                                     |
                    		 --------------
				 Service Broker
				     |
                                  Node Runtime



Use case : how to create Service broker and start

services/HelloWorldService.js
const { ServiceBroker } = require('moleculer');


//Create Service Broker Object
const broker = new ServiceBroker();


//start Service Broker

broker.start();





